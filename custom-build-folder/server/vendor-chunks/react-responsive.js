"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-responsive";
exports.ids = ["vendor-chunks/react-responsive"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-responsive/dist/react-responsive.js":
/*!****************************************************************!*\
  !*** ./node_modules/react-responsive/dist/react-responsive.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n(function webpackUniversalModuleDefinition(root, factory) {\n    if (true) module.exports = factory(__webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\"));\n    else {}\n})(void 0, (__WEBPACK_EXTERNAL_MODULE_react__)=>{\n    return /******/ (()=>{\n        /******/ var __webpack_modules__ = {\n            /***/ \"./node_modules/css-mediaquery/index.js\": /*!**********************************************!*\\\n  !*** ./node_modules/css-mediaquery/index.js ***!\n  \\**********************************************/ /***/ (__unused_webpack_module, exports1)=>{\n                \"use strict\";\n                /*\nCopyright (c) 2014, Yahoo! Inc. All rights reserved.\nCopyrights licensed under the New BSD License.\nSee the accompanying LICENSE file for terms.\n*/ exports1.match = matchQuery;\n                exports1.parse = parseQuery;\n                // -----------------------------------------------------------------------------\n                var RE_MEDIA_QUERY = /(?:(only|not)?\\s*([^\\s\\(\\)]+)(?:\\s*and)?\\s*)?(.+)?/i, RE_MQ_EXPRESSION = /\\(\\s*([^\\s\\:\\)]+)\\s*(?:\\:\\s*([^\\s\\)]+))?\\s*\\)/, RE_MQ_FEATURE = /^(?:(min|max)-)?(.+)/, RE_LENGTH_UNIT = /(em|rem|px|cm|mm|in|pt|pc)?$/, RE_RESOLUTION_UNIT = /(dpi|dpcm|dppx)?$/;\n                function matchQuery(mediaQuery, values) {\n                    return parseQuery(mediaQuery).some(function(query) {\n                        var inverse = query.inverse;\n                        // Either the parsed or specified `type` is \"all\", or the types must be\n                        // equal for a match.\n                        var typeMatch = query.type === \"all\" || values.type === query.type;\n                        // Quit early when `type` doesn't match, but take \"not\" into account.\n                        if (typeMatch && inverse || !(typeMatch || inverse)) {\n                            return false;\n                        }\n                        var expressionsMatch = query.expressions.every(function(expression) {\n                            var feature = expression.feature, modifier = expression.modifier, expValue = expression.value, value = values[feature];\n                            // Missing or falsy values don't match.\n                            if (!value) {\n                                return false;\n                            }\n                            switch(feature){\n                                case \"orientation\":\n                                case \"scan\":\n                                    return value.toLowerCase() === expValue.toLowerCase();\n                                case \"width\":\n                                case \"height\":\n                                case \"device-width\":\n                                case \"device-height\":\n                                    expValue = toPx(expValue);\n                                    value = toPx(value);\n                                    break;\n                                case \"resolution\":\n                                    expValue = toDpi(expValue);\n                                    value = toDpi(value);\n                                    break;\n                                case \"aspect-ratio\":\n                                case \"device-aspect-ratio\":\n                                case /* Deprecated */ \"device-pixel-ratio\":\n                                    expValue = toDecimal(expValue);\n                                    value = toDecimal(value);\n                                    break;\n                                case \"grid\":\n                                case \"color\":\n                                case \"color-index\":\n                                case \"monochrome\":\n                                    expValue = parseInt(expValue, 10) || 1;\n                                    value = parseInt(value, 10) || 0;\n                                    break;\n                            }\n                            switch(modifier){\n                                case \"min\":\n                                    return value >= expValue;\n                                case \"max\":\n                                    return value <= expValue;\n                                default:\n                                    return value === expValue;\n                            }\n                        });\n                        return expressionsMatch && !inverse || !expressionsMatch && inverse;\n                    });\n                }\n                function parseQuery(mediaQuery) {\n                    return mediaQuery.split(\",\").map(function(query) {\n                        query = query.trim();\n                        var captures = query.match(RE_MEDIA_QUERY), modifier = captures[1], type = captures[2], expressions = captures[3] || \"\", parsed = {};\n                        parsed.inverse = !!modifier && modifier.toLowerCase() === \"not\";\n                        parsed.type = type ? type.toLowerCase() : \"all\";\n                        // Split expressions into a list.\n                        expressions = expressions.match(/\\([^\\)]+\\)/g) || [];\n                        parsed.expressions = expressions.map(function(expression) {\n                            var captures = expression.match(RE_MQ_EXPRESSION), feature = captures[1].toLowerCase().match(RE_MQ_FEATURE);\n                            return {\n                                modifier: feature[1],\n                                feature: feature[2],\n                                value: captures[2]\n                            };\n                        });\n                        return parsed;\n                    });\n                }\n                // -- Utilities ----------------------------------------------------------------\n                function toDecimal(ratio) {\n                    var decimal = Number(ratio), numbers;\n                    if (!decimal) {\n                        numbers = ratio.match(/^(\\d+)\\s*\\/\\s*(\\d+)$/);\n                        decimal = numbers[1] / numbers[2];\n                    }\n                    return decimal;\n                }\n                function toDpi(resolution) {\n                    var value = parseFloat(resolution), units = String(resolution).match(RE_RESOLUTION_UNIT)[1];\n                    switch(units){\n                        case \"dpcm\":\n                            return value / 2.54;\n                        case \"dppx\":\n                            return value * 96;\n                        default:\n                            return value;\n                    }\n                }\n                function toPx(length) {\n                    var value = parseFloat(length), units = String(length).match(RE_LENGTH_UNIT)[1];\n                    switch(units){\n                        case \"em\":\n                            return value * 16;\n                        case \"rem\":\n                            return value * 16;\n                        case \"cm\":\n                            return value * 96 / 2.54;\n                        case \"mm\":\n                            return value * 96 / 2.54 / 10;\n                        case \"in\":\n                            return value * 96;\n                        case \"pt\":\n                            return value * 72;\n                        case \"pc\":\n                            return value * 72 / 12;\n                        default:\n                            return value;\n                    }\n                }\n            /***/ },\n            /***/ \"./node_modules/hyphenate-style-name/index.js\": /*!****************************************************!*\\\n  !*** ./node_modules/hyphenate-style-name/index.js ***!\n  \\****************************************************/ /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_8002__)=>{\n                \"use strict\";\n                __nested_webpack_require_8002__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_8002__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"default\": ()=>__WEBPACK_DEFAULT_EXPORT__\n                });\n                /* eslint-disable no-var, prefer-template */ var uppercasePattern = /[A-Z]/g;\n                var msPattern = /^ms-/;\n                var cache = {};\n                function toHyphenLower(match) {\n                    return \"-\" + match.toLowerCase();\n                }\n                function hyphenateStyleName(name) {\n                    if (cache.hasOwnProperty(name)) {\n                        return cache[name];\n                    }\n                    var hName = name.replace(uppercasePattern, toHyphenLower);\n                    return cache[name] = msPattern.test(hName) ? \"-\" + hName : hName;\n                }\n                /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = hyphenateStyleName;\n            /***/ },\n            /***/ \"./node_modules/matchmediaquery/index.js\": /*!***********************************************!*\\\n  !*** ./node_modules/matchmediaquery/index.js ***!\n  \\***********************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_9324__)=>{\n                \"use strict\";\n                var staticMatch = __nested_webpack_require_9324__(/*! css-mediaquery */ \"./node_modules/css-mediaquery/index.js\").match;\n                var dynamicMatch =  false ? 0 : null;\n                // our fake MediaQueryList\n                function Mql(query, values, forceStatic) {\n                    var self = this;\n                    if (dynamicMatch && !forceStatic) {\n                        var mql = dynamicMatch.call(window, query);\n                        this.matches = mql.matches;\n                        this.media = mql.media;\n                        // TODO: is there a time it makes sense to remove this listener?\n                        mql.addListener(update);\n                    } else {\n                        this.matches = staticMatch(query, values);\n                        this.media = query;\n                    }\n                    this.addListener = addListener;\n                    this.removeListener = removeListener;\n                    this.dispose = dispose;\n                    function addListener(listener) {\n                        if (mql) {\n                            mql.addListener(listener);\n                        }\n                    }\n                    function removeListener(listener) {\n                        if (mql) {\n                            mql.removeListener(listener);\n                        }\n                    }\n                    // update ourselves!\n                    function update(evt) {\n                        self.matches = evt.matches;\n                        self.media = evt.media;\n                    }\n                    function dispose() {\n                        if (mql) {\n                            mql.removeListener(update);\n                        }\n                    }\n                }\n                function matchMedia(query, values, forceStatic) {\n                    return new Mql(query, values, forceStatic);\n                }\n                module1.exports = matchMedia;\n            /***/ },\n            /***/ \"./node_modules/object-assign/index.js\": /*!*********************************************!*\\\n  !*** ./node_modules/object-assign/index.js ***!\n  \\*********************************************/ /***/ (module1)=>{\n                \"use strict\";\n                /*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/ /* eslint-disable no-unused-vars */ var getOwnPropertySymbols = Object.getOwnPropertySymbols;\n                var hasOwnProperty = Object.prototype.hasOwnProperty;\n                var propIsEnumerable = Object.prototype.propertyIsEnumerable;\n                function toObject(val) {\n                    if (val === null || val === undefined) {\n                        throw new TypeError(\"Object.assign cannot be called with null or undefined\");\n                    }\n                    return Object(val);\n                }\n                function shouldUseNative() {\n                    try {\n                        if (!Object.assign) {\n                            return false;\n                        }\n                        // Detect buggy property enumeration order in older V8 versions.\n                        // https://bugs.chromium.org/p/v8/issues/detail?id=4118\n                        var test1 = new String(\"abc\"); // eslint-disable-line no-new-wrappers\n                        test1[5] = \"de\";\n                        if (Object.getOwnPropertyNames(test1)[0] === \"5\") {\n                            return false;\n                        }\n                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                        var test2 = {};\n                        for(var i = 0; i < 10; i++){\n                            test2[\"_\" + String.fromCharCode(i)] = i;\n                        }\n                        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {\n                            return test2[n];\n                        });\n                        if (order2.join(\"\") !== \"0123456789\") {\n                            return false;\n                        }\n                        // https://bugs.chromium.org/p/v8/issues/detail?id=3056\n                        var test3 = {};\n                        \"abcdefghijklmnopqrst\".split(\"\").forEach(function(letter) {\n                            test3[letter] = letter;\n                        });\n                        if (Object.keys(Object.assign({}, test3)).join(\"\") !== \"abcdefghijklmnopqrst\") {\n                            return false;\n                        }\n                        return true;\n                    } catch (err) {\n                        // We don't expect any of the above to throw, but better to be safe.\n                        return false;\n                    }\n                }\n                module1.exports = shouldUseNative() ? Object.assign : function(target, source) {\n                    var from;\n                    var to = toObject(target);\n                    var symbols;\n                    for(var s = 1; s < arguments.length; s++){\n                        from = Object(arguments[s]);\n                        for(var key in from){\n                            if (hasOwnProperty.call(from, key)) {\n                                to[key] = from[key];\n                            }\n                        }\n                        if (getOwnPropertySymbols) {\n                            symbols = getOwnPropertySymbols(from);\n                            for(var i = 0; i < symbols.length; i++){\n                                if (propIsEnumerable.call(from, symbols[i])) {\n                                    to[symbols[i]] = from[symbols[i]];\n                                }\n                            }\n                        }\n                    }\n                    return to;\n                };\n            /***/ },\n            /***/ \"./node_modules/prop-types/checkPropTypes.js\": /*!***************************************************!*\\\n  !*** ./node_modules/prop-types/checkPropTypes.js ***!\n  \\***************************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_15510__)=>{\n                \"use strict\";\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var printWarning = function() {};\n                if (true) {\n                    var ReactPropTypesSecret = __nested_webpack_require_15510__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n                    var loggedTypeFailures = {};\n                    var has = __nested_webpack_require_15510__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n                    printWarning = function(text) {\n                        var message = \"Warning: \" + text;\n                        if (typeof console !== \"undefined\") {\n                            console.error(message);\n                        }\n                        try {\n                            // --- Welcome to debugging React ---\n                            // This error was thrown as a convenience so that you can use this stack\n                            // to find the callsite that caused this warning to fire.\n                            throw new Error(message);\n                        } catch (x) {}\n                    };\n                }\n                /**\n * Assert that the values match with the type specs.\n * Error messages are memorized and will only be shown once.\n *\n * @param {object} typeSpecs Map of name to a ReactPropType\n * @param {object} values Runtime values that need to be type-checked\n * @param {string} location e.g. \"prop\", \"context\", \"child context\"\n * @param {string} componentName Name of the component for error messages.\n * @param {?Function} getStack Returns the component stack.\n * @private\n */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {\n                    if (true) {\n                        for(var typeSpecName in typeSpecs){\n                            if (has(typeSpecs, typeSpecName)) {\n                                var error;\n                                // Prop type validation may throw. In case they do, we don't want to\n                                // fail the render phase where it didn't fail before. So we log it.\n                                // After these have been cleaned up, we'll let them throw.\n                                try {\n                                    // This is intentionally an invariant that gets caught. It's the same\n                                    // behavior as without this statement except with a better message.\n                                    if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                        var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                        err.name = \"Invariant Violation\";\n                                        throw err;\n                                    }\n                                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);\n                                } catch (ex) {\n                                    error = ex;\n                                }\n                                if (error && !(error instanceof Error)) {\n                                    printWarning((componentName || \"React class\") + \": type specification of \" + location + \" `\" + typeSpecName + \"` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a \" + typeof error + \". \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\");\n                                }\n                                if (error instanceof Error && !(error.message in loggedTypeFailures)) {\n                                    // Only monitor this failure once because there tends to be a lot of the\n                                    // same error.\n                                    loggedTypeFailures[error.message] = true;\n                                    var stack = getStack ? getStack() : \"\";\n                                    printWarning(\"Failed \" + location + \" type: \" + error.message + (stack != null ? stack : \"\"));\n                                }\n                            }\n                        }\n                    }\n                }\n                /**\n * Resets warning cache when testing.\n *\n * @private\n */ checkPropTypes.resetWarningCache = function() {\n                    if (true) {\n                        loggedTypeFailures = {};\n                    }\n                };\n                module1.exports = checkPropTypes;\n            /***/ },\n            /***/ \"./node_modules/prop-types/factoryWithTypeCheckers.js\": /*!************************************************************!*\\\n  !*** ./node_modules/prop-types/factoryWithTypeCheckers.js ***!\n  \\************************************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_20867__)=>{\n                \"use strict\";\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var ReactIs = __nested_webpack_require_20867__(/*! react-is */ \"./node_modules/react-is/index.js\");\n                var assign = __nested_webpack_require_20867__(/*! object-assign */ \"./node_modules/object-assign/index.js\");\n                var ReactPropTypesSecret = __nested_webpack_require_20867__(/*! ./lib/ReactPropTypesSecret */ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\");\n                var has = __nested_webpack_require_20867__(/*! ./lib/has */ \"./node_modules/prop-types/lib/has.js\");\n                var checkPropTypes = __nested_webpack_require_20867__(/*! ./checkPropTypes */ \"./node_modules/prop-types/checkPropTypes.js\");\n                var printWarning = function() {};\n                if (true) {\n                    printWarning = function(text) {\n                        var message = \"Warning: \" + text;\n                        if (typeof console !== \"undefined\") {\n                            console.error(message);\n                        }\n                        try {\n                            // --- Welcome to debugging React ---\n                            // This error was thrown as a convenience so that you can use this stack\n                            // to find the callsite that caused this warning to fire.\n                            throw new Error(message);\n                        } catch (x) {}\n                    };\n                }\n                function emptyFunctionThatReturnsNull() {\n                    return null;\n                }\n                module1.exports = function(isValidElement, throwOnDirectAccess) {\n                    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === \"function\" && Symbol.iterator;\n                    var FAUX_ITERATOR_SYMBOL = \"@@iterator\"; // Before Symbol spec.\n                    /**\n   * Returns the iterator method function contained on the iterable object.\n   *\n   * Be sure to invoke the function with the iterable as context:\n   *\n   *     var iteratorFn = getIteratorFn(myIterable);\n   *     if (iteratorFn) {\n   *       var iterator = iteratorFn.call(myIterable);\n   *       ...\n   *     }\n   *\n   * @param {?object} maybeIterable\n   * @return {?function}\n   */ function getIteratorFn(maybeIterable) {\n                        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);\n                        if (typeof iteratorFn === \"function\") {\n                            return iteratorFn;\n                        }\n                    }\n                    /**\n   * Collection of methods that allow declaration and validation of props that are\n   * supplied to React components. Example usage:\n   *\n   *   var Props = require('ReactPropTypes');\n   *   var MyArticle = React.createClass({\n   *     propTypes: {\n   *       // An optional string prop named \"description\".\n   *       description: Props.string,\n   *\n   *       // A required enum prop named \"category\".\n   *       category: Props.oneOf(['News','Photos']).isRequired,\n   *\n   *       // A prop named \"dialog\" that requires an instance of Dialog.\n   *       dialog: Props.instanceOf(Dialog).isRequired\n   *     },\n   *     render: function() { ... }\n   *   });\n   *\n   * A more formal specification of how these methods are used:\n   *\n   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)\n   *   decl := ReactPropTypes.{type}(.isRequired)?\n   *\n   * Each and every declaration produces a function with the same signature. This\n   * allows the creation of custom validation functions. For example:\n   *\n   *  var MyLink = React.createClass({\n   *    propTypes: {\n   *      // An optional string or URI prop named \"href\".\n   *      href: function(props, propName, componentName) {\n   *        var propValue = props[propName];\n   *        if (propValue != null && typeof propValue !== 'string' &&\n   *            !(propValue instanceof URI)) {\n   *          return new Error(\n   *            'Expected a string or an URI for ' + propName + ' in ' +\n   *            componentName\n   *          );\n   *        }\n   *      }\n   *    },\n   *    render: function() {...}\n   *  });\n   *\n   * @internal\n   */ var ANONYMOUS = \"<<anonymous>>\";\n                    // Important!\n                    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.\n                    var ReactPropTypes = {\n                        array: createPrimitiveTypeChecker(\"array\"),\n                        bigint: createPrimitiveTypeChecker(\"bigint\"),\n                        bool: createPrimitiveTypeChecker(\"boolean\"),\n                        func: createPrimitiveTypeChecker(\"function\"),\n                        number: createPrimitiveTypeChecker(\"number\"),\n                        object: createPrimitiveTypeChecker(\"object\"),\n                        string: createPrimitiveTypeChecker(\"string\"),\n                        symbol: createPrimitiveTypeChecker(\"symbol\"),\n                        any: createAnyTypeChecker(),\n                        arrayOf: createArrayOfTypeChecker,\n                        element: createElementTypeChecker(),\n                        elementType: createElementTypeTypeChecker(),\n                        instanceOf: createInstanceTypeChecker,\n                        node: createNodeChecker(),\n                        objectOf: createObjectOfTypeChecker,\n                        oneOf: createEnumTypeChecker,\n                        oneOfType: createUnionTypeChecker,\n                        shape: createShapeTypeChecker,\n                        exact: createStrictShapeTypeChecker\n                    };\n                    /**\n   * inlined Object.is polyfill to avoid requiring consumers ship their own\n   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n   */ /*eslint-disable no-self-compare*/ function is(x, y) {\n                        // SameValue algorithm\n                        if (x === y) {\n                            // Steps 1-5, 7-10\n                            // Steps 6.b-6.e: +0 != -0\n                            return x !== 0 || 1 / x === 1 / y;\n                        } else {\n                            // Step 6.a: NaN == NaN\n                            return x !== x && y !== y;\n                        }\n                    }\n                    /*eslint-enable no-self-compare*/ /**\n   * We use an Error-like object for backward compatibility as people may call\n   * PropTypes directly and inspect their output. However, we don't use real\n   * Errors anymore. We don't inspect their stack anyway, and creating them\n   * is prohibitively expensive if they are created too often, such as what\n   * happens in oneOfType() for any type before the one that matched.\n   */ function PropTypeError(message, data) {\n                        this.message = message;\n                        this.data = data && typeof data === \"object\" ? data : {};\n                        this.stack = \"\";\n                    }\n                    // Make `instanceof Error` still work for returned errors.\n                    PropTypeError.prototype = Error.prototype;\n                    function createChainableTypeChecker(validate) {\n                        if (true) {\n                            var manualPropTypeCallCache = {};\n                            var manualPropTypeWarningCount = 0;\n                        }\n                        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {\n                            componentName = componentName || ANONYMOUS;\n                            propFullName = propFullName || propName;\n                            if (secret !== ReactPropTypesSecret) {\n                                if (throwOnDirectAccess) {\n                                    // New behavior only for users of `prop-types` package\n                                    var err = new Error(\"Calling PropTypes validators directly is not supported by the `prop-types` package. \" + \"Use `PropTypes.checkPropTypes()` to call them. \" + \"Read more at http://fb.me/use-check-prop-types\");\n                                    err.name = \"Invariant Violation\";\n                                    throw err;\n                                } else if ( true && typeof console !== \"undefined\") {\n                                    // Old behavior for people using React.PropTypes\n                                    var cacheKey = componentName + \":\" + propName;\n                                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors\n                                    manualPropTypeWarningCount < 3) {\n                                        printWarning(\"You are manually calling a React.PropTypes validation \" + \"function for the `\" + propFullName + \"` prop on `\" + componentName + \"`. This is deprecated \" + \"and will throw in the standalone `prop-types` package. \" + \"You may be seeing this warning due to a third-party PropTypes \" + \"library. See https://fb.me/react-warning-dont-call-proptypes \" + \"for details.\");\n                                        manualPropTypeCallCache[cacheKey] = true;\n                                        manualPropTypeWarningCount++;\n                                    }\n                                }\n                            }\n                            if (props[propName] == null) {\n                                if (isRequired) {\n                                    if (props[propName] === null) {\n                                        return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required \" + (\"in `\" + componentName + \"`, but its value is `null`.\"));\n                                    }\n                                    return new PropTypeError(\"The \" + location + \" `\" + propFullName + \"` is marked as required in \" + (\"`\" + componentName + \"`, but its value is `undefined`.\"));\n                                }\n                                return null;\n                            } else {\n                                return validate(props, propName, componentName, location, propFullName);\n                            }\n                        }\n                        var chainedCheckType = checkType.bind(null, false);\n                        chainedCheckType.isRequired = checkType.bind(null, true);\n                        return chainedCheckType;\n                    }\n                    function createPrimitiveTypeChecker(expectedType) {\n                        function validate(props, propName, componentName, location, propFullName, secret) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== expectedType) {\n                                // `propValue` being instance of, say, date/regexp, pass the 'object'\n                                // check, but we can offer a more precise error message here rather than\n                                // 'of type `object`'.\n                                var preciseType = getPreciseType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + preciseType + \"` supplied to `\" + componentName + \"`, expected \") + (\"`\" + expectedType + \"`.\"), {\n                                    expectedType: expectedType\n                                });\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createAnyTypeChecker() {\n                        return createChainableTypeChecker(emptyFunctionThatReturnsNull);\n                    }\n                    function createArrayOfTypeChecker(typeChecker) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (typeof typeChecker !== \"function\") {\n                                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside arrayOf.\");\n                            }\n                            var propValue = props[propName];\n                            if (!Array.isArray(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an array.\"));\n                            }\n                            for(var i = 0; i < propValue.length; i++){\n                                var error = typeChecker(propValue, i, componentName, location, propFullName + \"[\" + i + \"]\", ReactPropTypesSecret);\n                                if (error instanceof Error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createElementTypeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            if (!isValidElement(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createElementTypeTypeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            if (!ReactIs.isValidElementType(propValue)) {\n                                var propType = getPropType(propValue);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected a single ReactElement type.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createInstanceTypeChecker(expectedClass) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (!(props[propName] instanceof expectedClass)) {\n                                var expectedClassName = expectedClass.name || ANONYMOUS;\n                                var actualClassName = getClassName(props[propName]);\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + actualClassName + \"` supplied to `\" + componentName + \"`, expected \") + (\"instance of `\" + expectedClassName + \"`.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createEnumTypeChecker(expectedValues) {\n                        if (!Array.isArray(expectedValues)) {\n                            if (true) {\n                                if (arguments.length > 1) {\n                                    printWarning(\"Invalid arguments supplied to oneOf, expected an array, got \" + arguments.length + \" arguments. \" + \"A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).\");\n                                } else {\n                                    printWarning(\"Invalid argument supplied to oneOf, expected an array.\");\n                                }\n                            }\n                            return emptyFunctionThatReturnsNull;\n                        }\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            for(var i = 0; i < expectedValues.length; i++){\n                                if (is(propValue, expectedValues[i])) {\n                                    return null;\n                                }\n                            }\n                            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {\n                                var type = getPreciseType(value);\n                                if (type === \"symbol\") {\n                                    return String(value);\n                                }\n                                return value;\n                            });\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of value `\" + String(propValue) + \"` \" + (\"supplied to `\" + componentName + \"`, expected one of \" + valuesString + \".\"));\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createObjectOfTypeChecker(typeChecker) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (typeof typeChecker !== \"function\") {\n                                return new PropTypeError(\"Property `\" + propFullName + \"` of component `\" + componentName + \"` has invalid PropType notation inside objectOf.\");\n                            }\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type \" + (\"`\" + propType + \"` supplied to `\" + componentName + \"`, expected an object.\"));\n                            }\n                            for(var key in propValue){\n                                if (has(propValue, key)) {\n                                    var error = typeChecker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                    if (error instanceof Error) {\n                                        return error;\n                                    }\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createUnionTypeChecker(arrayOfTypeCheckers) {\n                        if (!Array.isArray(arrayOfTypeCheckers)) {\n                             true ? printWarning(\"Invalid argument supplied to oneOfType, expected an instance of array.\") : 0;\n                            return emptyFunctionThatReturnsNull;\n                        }\n                        for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                            var checker = arrayOfTypeCheckers[i];\n                            if (typeof checker !== \"function\") {\n                                printWarning(\"Invalid argument supplied to oneOfType. Expected an array of check functions, but \" + \"received \" + getPostfixForTypeWarning(checker) + \" at index \" + i + \".\");\n                                return emptyFunctionThatReturnsNull;\n                            }\n                        }\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var expectedTypes = [];\n                            for(var i = 0; i < arrayOfTypeCheckers.length; i++){\n                                var checker = arrayOfTypeCheckers[i];\n                                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);\n                                if (checkerResult == null) {\n                                    return null;\n                                }\n                                if (checkerResult.data && has(checkerResult.data, \"expectedType\")) {\n                                    expectedTypes.push(checkerResult.data.expectedType);\n                                }\n                            }\n                            var expectedTypesMessage = expectedTypes.length > 0 ? \", expected one of type [\" + expectedTypes.join(\", \") + \"]\" : \"\";\n                            return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`\" + expectedTypesMessage + \".\"));\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createNodeChecker() {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            if (!isNode(props[propName])) {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` supplied to \" + (\"`\" + componentName + \"`, expected a ReactNode.\"));\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function invalidValidatorError(componentName, location, propFullName, key, type) {\n                        return new PropTypeError((componentName || \"React class\") + \": \" + location + \" type `\" + propFullName + \".\" + key + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + type + \"`.\");\n                    }\n                    function createShapeTypeChecker(shapeTypes) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                            }\n                            for(var key in shapeTypes){\n                                var checker = shapeTypes[key];\n                                if (typeof checker !== \"function\") {\n                                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                                }\n                                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function createStrictShapeTypeChecker(shapeTypes) {\n                        function validate(props, propName, componentName, location, propFullName) {\n                            var propValue = props[propName];\n                            var propType = getPropType(propValue);\n                            if (propType !== \"object\") {\n                                return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` of type `\" + propType + \"` \" + (\"supplied to `\" + componentName + \"`, expected `object`.\"));\n                            }\n                            // We need to check all keys in case some are required but missing from props.\n                            var allKeys = assign({}, props[propName], shapeTypes);\n                            for(var key in allKeys){\n                                var checker = shapeTypes[key];\n                                if (has(shapeTypes, key) && typeof checker !== \"function\") {\n                                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));\n                                }\n                                if (!checker) {\n                                    return new PropTypeError(\"Invalid \" + location + \" `\" + propFullName + \"` key `\" + key + \"` supplied to `\" + componentName + \"`.\" + \"\\nBad object: \" + JSON.stringify(props[propName], null, \"  \") + \"\\nValid keys: \" + JSON.stringify(Object.keys(shapeTypes), null, \"  \"));\n                                }\n                                var error = checker(propValue, key, componentName, location, propFullName + \".\" + key, ReactPropTypesSecret);\n                                if (error) {\n                                    return error;\n                                }\n                            }\n                            return null;\n                        }\n                        return createChainableTypeChecker(validate);\n                    }\n                    function isNode(propValue) {\n                        switch(typeof propValue){\n                            case \"number\":\n                            case \"string\":\n                            case \"undefined\":\n                                return true;\n                            case \"boolean\":\n                                return !propValue;\n                            case \"object\":\n                                if (Array.isArray(propValue)) {\n                                    return propValue.every(isNode);\n                                }\n                                if (propValue === null || isValidElement(propValue)) {\n                                    return true;\n                                }\n                                var iteratorFn = getIteratorFn(propValue);\n                                if (iteratorFn) {\n                                    var iterator = iteratorFn.call(propValue);\n                                    var step;\n                                    if (iteratorFn !== propValue.entries) {\n                                        while(!(step = iterator.next()).done){\n                                            if (!isNode(step.value)) {\n                                                return false;\n                                            }\n                                        }\n                                    } else {\n                                        // Iterator will provide entry [k,v] tuples rather than values.\n                                        while(!(step = iterator.next()).done){\n                                            var entry = step.value;\n                                            if (entry) {\n                                                if (!isNode(entry[1])) {\n                                                    return false;\n                                                }\n                                            }\n                                        }\n                                    }\n                                } else {\n                                    return false;\n                                }\n                                return true;\n                            default:\n                                return false;\n                        }\n                    }\n                    function isSymbol(propType, propValue) {\n                        // Native Symbol.\n                        if (propType === \"symbol\") {\n                            return true;\n                        }\n                        // falsy value can't be a Symbol\n                        if (!propValue) {\n                            return false;\n                        }\n                        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'\n                        if (propValue[\"@@toStringTag\"] === \"Symbol\") {\n                            return true;\n                        }\n                        // Fallback for non-spec compliant Symbols which are polyfilled.\n                        if (typeof Symbol === \"function\" && propValue instanceof Symbol) {\n                            return true;\n                        }\n                        return false;\n                    }\n                    // Equivalent of `typeof` but with special handling for array and regexp.\n                    function getPropType(propValue) {\n                        var propType = typeof propValue;\n                        if (Array.isArray(propValue)) {\n                            return \"array\";\n                        }\n                        if (propValue instanceof RegExp) {\n                            // Old webkits (at least until Android 4.0) return 'function' rather than\n                            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/\n                            // passes PropTypes.object.\n                            return \"object\";\n                        }\n                        if (isSymbol(propType, propValue)) {\n                            return \"symbol\";\n                        }\n                        return propType;\n                    }\n                    // This handles more types than `getPropType`. Only used for error messages.\n                    // See `createPrimitiveTypeChecker`.\n                    function getPreciseType(propValue) {\n                        if (typeof propValue === \"undefined\" || propValue === null) {\n                            return \"\" + propValue;\n                        }\n                        var propType = getPropType(propValue);\n                        if (propType === \"object\") {\n                            if (propValue instanceof Date) {\n                                return \"date\";\n                            } else if (propValue instanceof RegExp) {\n                                return \"regexp\";\n                            }\n                        }\n                        return propType;\n                    }\n                    // Returns a string that is postfixed to a warning about an invalid type.\n                    // For example, \"undefined\" or \"of type array\"\n                    function getPostfixForTypeWarning(value) {\n                        var type = getPreciseType(value);\n                        switch(type){\n                            case \"array\":\n                            case \"object\":\n                                return \"an \" + type;\n                            case \"boolean\":\n                            case \"date\":\n                            case \"regexp\":\n                                return \"a \" + type;\n                            default:\n                                return type;\n                        }\n                    }\n                    // Returns class name of the object, if any.\n                    function getClassName(propValue) {\n                        if (!propValue.constructor || !propValue.constructor.name) {\n                            return ANONYMOUS;\n                        }\n                        return propValue.constructor.name;\n                    }\n                    ReactPropTypes.checkPropTypes = checkPropTypes;\n                    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;\n                    ReactPropTypes.PropTypes = ReactPropTypes;\n                    return ReactPropTypes;\n                };\n            /***/ },\n            /***/ \"./node_modules/prop-types/index.js\": /*!******************************************!*\\\n  !*** ./node_modules/prop-types/index.js ***!\n  \\******************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_53409__)=>{\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                    var ReactIs = __nested_webpack_require_53409__(/*! react-is */ \"./node_modules/react-is/index.js\");\n                    // By explicitly using `prop-types` you are opting into new development behavior.\n                    // http://fb.me/prop-types-in-prod\n                    var throwOnDirectAccess = true;\n                    module1.exports = __nested_webpack_require_53409__(/*! ./factoryWithTypeCheckers */ \"./node_modules/prop-types/factoryWithTypeCheckers.js\")(ReactIs.isElement, throwOnDirectAccess);\n                } else {}\n            /***/ },\n            /***/ \"./node_modules/prop-types/lib/ReactPropTypesSecret.js\": /*!*************************************************************!*\\\n  !*** ./node_modules/prop-types/lib/ReactPropTypesSecret.js ***!\n  \\*************************************************************/ /***/ (module1)=>{\n                \"use strict\";\n                /**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ var ReactPropTypesSecret = \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\";\n                module1.exports = ReactPropTypesSecret;\n            /***/ },\n            /***/ \"./node_modules/prop-types/lib/has.js\": /*!********************************************!*\\\n  !*** ./node_modules/prop-types/lib/has.js ***!\n  \\********************************************/ /***/ (module1)=>{\n                module1.exports = Function.call.bind(Object.prototype.hasOwnProperty);\n            /***/ },\n            /***/ \"./node_modules/react-is/cjs/react-is.development.js\": /*!***********************************************************!*\\\n  !*** ./node_modules/react-is/cjs/react-is.development.js ***!\n  \\***********************************************************/ /***/ (__unused_webpack_module, exports1)=>{\n                \"use strict\";\n                /** @license React v16.13.1\n * react-is.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ if (true) {\n                    (function() {\n                        \"use strict\";\n                        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n                        // nor polyfill, then a plain number is used for performance.\n                        var hasSymbol = typeof Symbol === \"function\" && Symbol.for;\n                        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for(\"react.element\") : 0xeac7;\n                        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for(\"react.portal\") : 0xeaca;\n                        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for(\"react.fragment\") : 0xeacb;\n                        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.strict_mode\") : 0xeacc;\n                        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for(\"react.profiler\") : 0xead2;\n                        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for(\"react.provider\") : 0xeacd;\n                        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for(\"react.context\") : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary\n                        // (unstable) APIs that have been removed. Can we remove the symbols?\n                        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for(\"react.async_mode\") : 0xeacf;\n                        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for(\"react.concurrent_mode\") : 0xeacf;\n                        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for(\"react.forward_ref\") : 0xead0;\n                        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for(\"react.suspense\") : 0xead1;\n                        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for(\"react.suspense_list\") : 0xead8;\n                        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for(\"react.memo\") : 0xead3;\n                        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for(\"react.lazy\") : 0xead4;\n                        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for(\"react.block\") : 0xead9;\n                        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for(\"react.fundamental\") : 0xead5;\n                        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for(\"react.responder\") : 0xead6;\n                        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for(\"react.scope\") : 0xead7;\n                        function isValidElementType(type) {\n                            return typeof type === \"string\" || typeof type === \"function\" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.\n                            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === \"object\" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);\n                        }\n                        function typeOf(object) {\n                            if (typeof object === \"object\" && object !== null) {\n                                var $$typeof = object.$$typeof;\n                                switch($$typeof){\n                                    case REACT_ELEMENT_TYPE:\n                                        var type = object.type;\n                                        switch(type){\n                                            case REACT_ASYNC_MODE_TYPE:\n                                            case REACT_CONCURRENT_MODE_TYPE:\n                                            case REACT_FRAGMENT_TYPE:\n                                            case REACT_PROFILER_TYPE:\n                                            case REACT_STRICT_MODE_TYPE:\n                                            case REACT_SUSPENSE_TYPE:\n                                                return type;\n                                            default:\n                                                var $$typeofType = type && type.$$typeof;\n                                                switch($$typeofType){\n                                                    case REACT_CONTEXT_TYPE:\n                                                    case REACT_FORWARD_REF_TYPE:\n                                                    case REACT_LAZY_TYPE:\n                                                    case REACT_MEMO_TYPE:\n                                                    case REACT_PROVIDER_TYPE:\n                                                        return $$typeofType;\n                                                    default:\n                                                        return $$typeof;\n                                                }\n                                        }\n                                    case REACT_PORTAL_TYPE:\n                                        return $$typeof;\n                                }\n                            }\n                            return undefined;\n                        } // AsyncMode is deprecated along with isAsyncMode\n                        var AsyncMode = REACT_ASYNC_MODE_TYPE;\n                        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;\n                        var ContextConsumer = REACT_CONTEXT_TYPE;\n                        var ContextProvider = REACT_PROVIDER_TYPE;\n                        var Element = REACT_ELEMENT_TYPE;\n                        var ForwardRef = REACT_FORWARD_REF_TYPE;\n                        var Fragment = REACT_FRAGMENT_TYPE;\n                        var Lazy = REACT_LAZY_TYPE;\n                        var Memo = REACT_MEMO_TYPE;\n                        var Portal = REACT_PORTAL_TYPE;\n                        var Profiler = REACT_PROFILER_TYPE;\n                        var StrictMode = REACT_STRICT_MODE_TYPE;\n                        var Suspense = REACT_SUSPENSE_TYPE;\n                        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated\n                        function isAsyncMode(object) {\n                            {\n                                if (!hasWarnedAboutDeprecatedIsAsyncMode) {\n                                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint\n                                    console[\"warn\"](\"The ReactIs.isAsyncMode() alias has been deprecated, \" + \"and will be removed in React 17+. Update your code to use \" + \"ReactIs.isConcurrentMode() instead. It has the exact same API.\");\n                                }\n                            }\n                            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;\n                        }\n                        function isConcurrentMode(object) {\n                            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;\n                        }\n                        function isContextConsumer(object) {\n                            return typeOf(object) === REACT_CONTEXT_TYPE;\n                        }\n                        function isContextProvider(object) {\n                            return typeOf(object) === REACT_PROVIDER_TYPE;\n                        }\n                        function isElement(object) {\n                            return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n                        }\n                        function isForwardRef(object) {\n                            return typeOf(object) === REACT_FORWARD_REF_TYPE;\n                        }\n                        function isFragment(object) {\n                            return typeOf(object) === REACT_FRAGMENT_TYPE;\n                        }\n                        function isLazy(object) {\n                            return typeOf(object) === REACT_LAZY_TYPE;\n                        }\n                        function isMemo(object) {\n                            return typeOf(object) === REACT_MEMO_TYPE;\n                        }\n                        function isPortal(object) {\n                            return typeOf(object) === REACT_PORTAL_TYPE;\n                        }\n                        function isProfiler(object) {\n                            return typeOf(object) === REACT_PROFILER_TYPE;\n                        }\n                        function isStrictMode(object) {\n                            return typeOf(object) === REACT_STRICT_MODE_TYPE;\n                        }\n                        function isSuspense(object) {\n                            return typeOf(object) === REACT_SUSPENSE_TYPE;\n                        }\n                        exports1.AsyncMode = AsyncMode;\n                        exports1.ConcurrentMode = ConcurrentMode;\n                        exports1.ContextConsumer = ContextConsumer;\n                        exports1.ContextProvider = ContextProvider;\n                        exports1.Element = Element;\n                        exports1.ForwardRef = ForwardRef;\n                        exports1.Fragment = Fragment;\n                        exports1.Lazy = Lazy;\n                        exports1.Memo = Memo;\n                        exports1.Portal = Portal;\n                        exports1.Profiler = Profiler;\n                        exports1.StrictMode = StrictMode;\n                        exports1.Suspense = Suspense;\n                        exports1.isAsyncMode = isAsyncMode;\n                        exports1.isConcurrentMode = isConcurrentMode;\n                        exports1.isContextConsumer = isContextConsumer;\n                        exports1.isContextProvider = isContextProvider;\n                        exports1.isElement = isElement;\n                        exports1.isForwardRef = isForwardRef;\n                        exports1.isFragment = isFragment;\n                        exports1.isLazy = isLazy;\n                        exports1.isMemo = isMemo;\n                        exports1.isPortal = isPortal;\n                        exports1.isProfiler = isProfiler;\n                        exports1.isStrictMode = isStrictMode;\n                        exports1.isSuspense = isSuspense;\n                        exports1.isValidElementType = isValidElementType;\n                        exports1.typeOf = typeOf;\n                    })();\n                }\n            /***/ },\n            /***/ \"./node_modules/react-is/index.js\": /*!****************************************!*\\\n  !*** ./node_modules/react-is/index.js ***!\n  \\****************************************/ /***/ (module1, __unused_webpack_exports, __nested_webpack_require_66680__)=>{\n                \"use strict\";\n                if (false) {} else {\n                    module1.exports = __nested_webpack_require_66680__(/*! ./cjs/react-is.development.js */ \"./node_modules/react-is/cjs/react-is.development.js\");\n                }\n            /***/ },\n            /***/ \"./node_modules/shallow-equal/dist/index.esm.js\": /*!******************************************************!*\\\n  !*** ./node_modules/shallow-equal/dist/index.esm.js ***!\n  \\******************************************************/ /***/ (__unused_webpack_module, __nested_webpack_exports__, __nested_webpack_require_67261__)=>{\n                \"use strict\";\n                __nested_webpack_require_67261__.r(__nested_webpack_exports__);\n                /* harmony export */ __nested_webpack_require_67261__.d(__nested_webpack_exports__, {\n                    /* harmony export */ \"shallowEqualArrays\": ()=>/* binding */ shallowEqualArrays,\n                    /* harmony export */ \"shallowEqualObjects\": ()=>/* binding */ shallowEqualObjects\n                });\n                function shallowEqualObjects(objA, objB) {\n                    if (objA === objB) {\n                        return true;\n                    }\n                    if (!objA || !objB) {\n                        return false;\n                    }\n                    var aKeys = Object.keys(objA);\n                    var bKeys = Object.keys(objB);\n                    var len = aKeys.length;\n                    if (bKeys.length !== len) {\n                        return false;\n                    }\n                    for(var i = 0; i < len; i++){\n                        var key = aKeys[i];\n                        if (objA[key] !== objB[key] || !Object.prototype.hasOwnProperty.call(objB, key)) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                function shallowEqualArrays(arrA, arrB) {\n                    if (arrA === arrB) {\n                        return true;\n                    }\n                    if (!arrA || !arrB) {\n                        return false;\n                    }\n                    var len = arrA.length;\n                    if (arrB.length !== len) {\n                        return false;\n                    }\n                    for(var i = 0; i < len; i++){\n                        if (arrA[i] !== arrB[i]) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            /***/ },\n            /***/ \"./src/Component.ts\": /*!**************************!*\\\n  !*** ./src/Component.ts ***!\n  \\**************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_69395__) {\n                \"use strict\";\n                var __rest = this && this.__rest || function(s, e) {\n                    var t = {};\n                    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n                    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n                    }\n                    return t;\n                };\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var useMediaQuery_1 = __importDefault(__nested_webpack_require_69395__(/*! ./useMediaQuery */ \"./src/useMediaQuery.ts\"));\n                // ReactNode and ReactElement typings are a little funky for functional components, so the ReactElement cast is needed on the return\n                var MediaQuery = function(_a) {\n                    var children = _a.children, device = _a.device, onChange = _a.onChange, settings = __rest(_a, [\n                        \"children\",\n                        \"device\",\n                        \"onChange\"\n                    ]);\n                    var matches = (0, useMediaQuery_1.default)(settings, device, onChange);\n                    if (typeof children === \"function\") {\n                        return children(matches);\n                    }\n                    return matches ? children : null;\n                };\n                exports1[\"default\"] = MediaQuery;\n            /***/ },\n            /***/ \"./src/Context.ts\": /*!************************!*\\\n  !*** ./src/Context.ts ***!\n  \\************************/ /***/ (__unused_webpack_module, exports1, __nested_webpack_require_71464__)=>{\n                \"use strict\";\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var react_1 = __nested_webpack_require_71464__(/*! react */ \"react\");\n                var Context = (0, react_1.createContext)(undefined);\n                exports1[\"default\"] = Context;\n            /***/ },\n            /***/ \"./src/index.ts\": /*!**********************!*\\\n  !*** ./src/index.ts ***!\n  \\**********************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_72013__) {\n                \"use strict\";\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                exports1.Context = exports1.toQuery = exports1.useMediaQuery = exports1[\"default\"] = void 0;\n                var useMediaQuery_1 = __importDefault(__nested_webpack_require_72013__(/*! ./useMediaQuery */ \"./src/useMediaQuery.ts\"));\n                exports1.useMediaQuery = useMediaQuery_1.default;\n                var Component_1 = __importDefault(__nested_webpack_require_72013__(/*! ./Component */ \"./src/Component.ts\"));\n                exports1[\"default\"] = Component_1.default;\n                var toQuery_1 = __importDefault(__nested_webpack_require_72013__(/*! ./toQuery */ \"./src/toQuery.ts\"));\n                exports1.toQuery = toQuery_1.default;\n                var Context_1 = __importDefault(__nested_webpack_require_72013__(/*! ./Context */ \"./src/Context.ts\"));\n                exports1.Context = Context_1.default;\n            /***/ },\n            /***/ \"./src/mediaQuery.ts\": /*!***************************!*\\\n  !*** ./src/mediaQuery.ts ***!\n  \\***************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_73412__) {\n                \"use strict\";\n                var __assign = this && this.__assign || function() {\n                    __assign = Object.assign || function(t) {\n                        for(var s, i = 1, n = arguments.length; i < n; i++){\n                            s = arguments[i];\n                            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n                        }\n                        return t;\n                    };\n                    return __assign.apply(this, arguments);\n                };\n                var __rest = this && this.__rest || function(s, e) {\n                    var t = {};\n                    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n                    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n                        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n                    }\n                    return t;\n                };\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var prop_types_1 = __importDefault(__nested_webpack_require_73412__(/*! prop-types */ \"./node_modules/prop-types/index.js\"));\n                var stringOrNumber = prop_types_1.default.oneOfType([\n                    prop_types_1.default.string,\n                    prop_types_1.default.number\n                ]);\n                // media types\n                var types = {\n                    all: prop_types_1.default.bool,\n                    grid: prop_types_1.default.bool,\n                    aural: prop_types_1.default.bool,\n                    braille: prop_types_1.default.bool,\n                    handheld: prop_types_1.default.bool,\n                    print: prop_types_1.default.bool,\n                    projection: prop_types_1.default.bool,\n                    screen: prop_types_1.default.bool,\n                    tty: prop_types_1.default.bool,\n                    tv: prop_types_1.default.bool,\n                    embossed: prop_types_1.default.bool\n                };\n                // properties that match media queries\n                var matchers = {\n                    orientation: prop_types_1.default.oneOf([\n                        \"portrait\",\n                        \"landscape\"\n                    ]),\n                    scan: prop_types_1.default.oneOf([\n                        \"progressive\",\n                        \"interlace\"\n                    ]),\n                    aspectRatio: prop_types_1.default.string,\n                    deviceAspectRatio: prop_types_1.default.string,\n                    height: stringOrNumber,\n                    deviceHeight: stringOrNumber,\n                    width: stringOrNumber,\n                    deviceWidth: stringOrNumber,\n                    color: prop_types_1.default.bool,\n                    colorIndex: prop_types_1.default.bool,\n                    monochrome: prop_types_1.default.bool,\n                    resolution: stringOrNumber,\n                    type: Object.keys(types)\n                };\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var type = matchers.type, featureMatchers = __rest(matchers, [\n                    \"type\"\n                ]);\n                // media features\n                var features = __assign({\n                    minAspectRatio: prop_types_1.default.string,\n                    maxAspectRatio: prop_types_1.default.string,\n                    minDeviceAspectRatio: prop_types_1.default.string,\n                    maxDeviceAspectRatio: prop_types_1.default.string,\n                    minHeight: stringOrNumber,\n                    maxHeight: stringOrNumber,\n                    minDeviceHeight: stringOrNumber,\n                    maxDeviceHeight: stringOrNumber,\n                    minWidth: stringOrNumber,\n                    maxWidth: stringOrNumber,\n                    minDeviceWidth: stringOrNumber,\n                    maxDeviceWidth: stringOrNumber,\n                    minColor: prop_types_1.default.number,\n                    maxColor: prop_types_1.default.number,\n                    minColorIndex: prop_types_1.default.number,\n                    maxColorIndex: prop_types_1.default.number,\n                    minMonochrome: prop_types_1.default.number,\n                    maxMonochrome: prop_types_1.default.number,\n                    minResolution: stringOrNumber,\n                    maxResolution: stringOrNumber\n                }, featureMatchers);\n                var all = __assign(__assign({}, types), features);\n                exports1[\"default\"] = {\n                    all: all,\n                    types: types,\n                    matchers: matchers,\n                    features: features\n                };\n            /***/ },\n            /***/ \"./src/toQuery.ts\": /*!************************!*\\\n  !*** ./src/toQuery.ts ***!\n  \\************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_78821__) {\n                \"use strict\";\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var hyphenate_style_name_1 = __importDefault(__nested_webpack_require_78821__(/*! hyphenate-style-name */ \"./node_modules/hyphenate-style-name/index.js\"));\n                var mediaQuery_1 = __importDefault(__nested_webpack_require_78821__(/*! ./mediaQuery */ \"./src/mediaQuery.ts\"));\n                var negate = function(cond) {\n                    return \"not \".concat(cond);\n                };\n                var keyVal = function(k, v) {\n                    var realKey = (0, hyphenate_style_name_1.default)(k);\n                    // px shorthand\n                    if (typeof v === \"number\") {\n                        v = \"\".concat(v, \"px\");\n                    }\n                    if (v === true) {\n                        return realKey;\n                    }\n                    if (v === false) {\n                        return negate(realKey);\n                    }\n                    return \"(\".concat(realKey, \": \").concat(v, \")\");\n                };\n                var join = function(conds) {\n                    return conds.join(\" and \");\n                };\n                var toQuery = function(obj) {\n                    var rules = [];\n                    Object.keys(mediaQuery_1.default.all).forEach(function(k) {\n                        var v = obj[k];\n                        if (v != null) {\n                            rules.push(keyVal(k, v));\n                        }\n                    });\n                    return join(rules);\n                };\n                exports1[\"default\"] = toQuery;\n            /***/ },\n            /***/ \"./src/useMediaQuery.ts\": /*!******************************!*\\\n  !*** ./src/useMediaQuery.ts ***!\n  \\******************************/ /***/ function(__unused_webpack_module, exports1, __nested_webpack_require_80963__) {\n                \"use strict\";\n                var __importDefault = this && this.__importDefault || function(mod) {\n                    return mod && mod.__esModule ? mod : {\n                        \"default\": mod\n                    };\n                };\n                Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n                var react_1 = __nested_webpack_require_80963__(/*! react */ \"react\");\n                var matchmediaquery_1 = __importDefault(__nested_webpack_require_80963__(/*! matchmediaquery */ \"./node_modules/matchmediaquery/index.js\"));\n                var hyphenate_style_name_1 = __importDefault(__nested_webpack_require_80963__(/*! hyphenate-style-name */ \"./node_modules/hyphenate-style-name/index.js\"));\n                var shallow_equal_1 = __nested_webpack_require_80963__(/*! shallow-equal */ \"./node_modules/shallow-equal/dist/index.esm.js\");\n                var toQuery_1 = __importDefault(__nested_webpack_require_80963__(/*! ./toQuery */ \"./src/toQuery.ts\"));\n                var Context_1 = __importDefault(__nested_webpack_require_80963__(/*! ./Context */ \"./src/Context.ts\"));\n                var makeQuery = function(settings) {\n                    return settings.query || (0, toQuery_1.default)(settings);\n                };\n                var hyphenateKeys = function(obj) {\n                    if (!obj) return undefined;\n                    var keys = Object.keys(obj);\n                    return keys.reduce(function(result, key) {\n                        result[(0, hyphenate_style_name_1.default)(key)] = obj[key];\n                        return result;\n                    }, {});\n                };\n                var useIsUpdate = function() {\n                    var ref = (0, react_1.useRef)(false);\n                    (0, react_1.useEffect)(function() {\n                        ref.current = true;\n                    }, []);\n                    return ref.current;\n                };\n                var useDevice = function(deviceFromProps) {\n                    var deviceFromContext = (0, react_1.useContext)(Context_1.default);\n                    var getDevice = function() {\n                        return hyphenateKeys(deviceFromProps) || hyphenateKeys(deviceFromContext);\n                    };\n                    var _a = (0, react_1.useState)(getDevice), device = _a[0], setDevice = _a[1];\n                    (0, react_1.useEffect)(function() {\n                        var newDevice = getDevice();\n                        if (!(0, shallow_equal_1.shallowEqualObjects)(device, newDevice)) {\n                            setDevice(newDevice);\n                        }\n                    }, [\n                        deviceFromProps,\n                        deviceFromContext\n                    ]);\n                    return device;\n                };\n                var useQuery = function(settings) {\n                    var getQuery = function() {\n                        return makeQuery(settings);\n                    };\n                    var _a = (0, react_1.useState)(getQuery), query = _a[0], setQuery = _a[1];\n                    (0, react_1.useEffect)(function() {\n                        var newQuery = getQuery();\n                        if (query !== newQuery) {\n                            setQuery(newQuery);\n                        }\n                    }, [\n                        settings\n                    ]);\n                    return query;\n                };\n                var useMatchMedia = function(query, device) {\n                    var getMatchMedia = function() {\n                        return (0, matchmediaquery_1.default)(query, device || {}, !!device);\n                    };\n                    var _a = (0, react_1.useState)(getMatchMedia), mq = _a[0], setMq = _a[1];\n                    var isUpdate = useIsUpdate();\n                    (0, react_1.useEffect)(function() {\n                        if (isUpdate) {\n                            // skip on mounting, it has already been set\n                            var newMq_1 = getMatchMedia();\n                            setMq(newMq_1);\n                            return function() {\n                                if (newMq_1) {\n                                    newMq_1.dispose();\n                                }\n                            };\n                        }\n                    }, [\n                        query,\n                        device\n                    ]);\n                    return mq;\n                };\n                var useMatches = function(mediaQuery) {\n                    var _a = (0, react_1.useState)(mediaQuery.matches), matches = _a[0], setMatches = _a[1];\n                    (0, react_1.useEffect)(function() {\n                        var updateMatches = function(ev) {\n                            setMatches(ev.matches);\n                        };\n                        mediaQuery.addListener(updateMatches);\n                        setMatches(mediaQuery.matches);\n                        return function() {\n                            mediaQuery.removeListener(updateMatches);\n                        };\n                    }, [\n                        mediaQuery\n                    ]);\n                    return matches;\n                };\n                var useMediaQuery = function(settings, device, onChange) {\n                    var deviceSettings = useDevice(device);\n                    var query = useQuery(settings);\n                    if (!query) throw new Error(\"Invalid or missing MediaQuery!\");\n                    var mq = useMatchMedia(query, deviceSettings);\n                    var matches = useMatches(mq);\n                    var isUpdate = useIsUpdate();\n                    (0, react_1.useEffect)(function() {\n                        if (isUpdate && onChange) {\n                            onChange(matches);\n                        }\n                    }, [\n                        matches\n                    ]);\n                    (0, react_1.useEffect)(function() {\n                        return function() {\n                            if (mq) {\n                                mq.dispose();\n                            }\n                        };\n                    }, []);\n                    return matches;\n                };\n                exports1[\"default\"] = useMediaQuery;\n            /***/ },\n            /***/ \"react\": /*!**************************************************************************************!*\\\n  !*** external {\"commonjs\":\"react\",\"commonjs2\":\"react\",\"amd\":\"react\",\"root\":\"React\"} ***!\n  \\**************************************************************************************/ /***/ (module1)=>{\n                \"use strict\";\n                module1.exports = __WEBPACK_EXTERNAL_MODULE_react__;\n            /***/ }\n        };\n        /************************************************************************/ /******/ // The module cache\n        /******/ var __webpack_module_cache__ = {};\n        /******/ /******/ // The require function\n        /******/ function __nested_webpack_require_88007__(moduleId) {\n            /******/ // Check if module is in cache\n            /******/ var cachedModule = __webpack_module_cache__[moduleId];\n            /******/ if (cachedModule !== undefined) {\n                /******/ return cachedModule.exports;\n            /******/ }\n            /******/ // Create a new module (and put it into the cache)\n            /******/ var module1 = __webpack_module_cache__[moduleId] = {\n                /******/ // no module.id needed\n                /******/ // no module.loaded needed\n                /******/ exports: {}\n            };\n            /******/ /******/ // Execute the module function\n            /******/ __webpack_modules__[moduleId].call(module1.exports, module1, module1.exports, __nested_webpack_require_88007__);\n            /******/ /******/ // Return the exports of the module\n            /******/ return module1.exports;\n        /******/ }\n        /******/ /************************************************************************/ /******/ /* webpack/runtime/define property getters */ /******/ (()=>{\n            /******/ // define getter functions for harmony exports\n            /******/ __nested_webpack_require_88007__.d = (exports1, definition)=>{\n                /******/ for(var key in definition){\n                    /******/ if (__nested_webpack_require_88007__.o(definition, key) && !__nested_webpack_require_88007__.o(exports1, key)) {\n                        /******/ Object.defineProperty(exports1, key, {\n                            enumerable: true,\n                            get: definition[key]\n                        });\n                    /******/ }\n                /******/ }\n            /******/ };\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/hasOwnProperty shorthand */ /******/ (()=>{\n            /******/ __nested_webpack_require_88007__.o = (obj, prop)=>Object.prototype.hasOwnProperty.call(obj, prop);\n        /******/ })();\n        /******/ /******/ /* webpack/runtime/make namespace object */ /******/ (()=>{\n            /******/ // define __esModule on exports\n            /******/ __nested_webpack_require_88007__.r = (exports1)=>{\n                /******/ if (typeof Symbol !== \"undefined\" && Symbol.toStringTag) {\n                    /******/ Object.defineProperty(exports1, Symbol.toStringTag, {\n                        value: \"Module\"\n                    });\n                /******/ }\n                /******/ Object.defineProperty(exports1, \"__esModule\", {\n                    value: true\n                });\n            /******/ };\n        /******/ })();\n        /******/ /************************************************************************/ /******/ /******/ // startup\n        /******/ // Load entry module and return exports\n        /******/ // This entry module is referenced by other modules so it can't be inlined\n        /******/ var __nested_webpack_exports__ = __nested_webpack_require_88007__(\"./src/index.ts\");\n        /******/ /******/ return __nested_webpack_exports__;\n    /******/ })();\n}); //# sourceMappingURL=react-responsive.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS9kaXN0L3JlYWN0LXJlc3BvbnNpdmUuanMiLCJtYXBwaW5ncyI6IjtBQUFDLFVBQVNBLGlDQUFpQ0MsSUFBSSxFQUFFQyxPQUFPO0lBQ3ZELElBQUcsSUFBaUQsRUFDbkRFLE9BQU9ELE9BQU8sR0FBR0QsUUFBUUcsbUJBQU9BLENBQUMsd0dBQU87U0FDcEMsRUFLd0M7QUFDOUMsR0FBRyxRQUFNLENBQUNHO0lBQ1YsT0FBZ0IsTUFBSCxHQUFJO1FBQ2pCLE1BQU0sR0FBSSxJQUFJQyxzQkFBdUI7WUFFckMsR0FBRyxHQUFHLDBDQUNOOztnREFFZ0QsR0FDaEQsR0FBRyxHQUFJLENBQUNDLHlCQUF5QlA7Z0JBRWpDO2dCQUNBOzs7O0FBSUEsR0FJQUEsU0FBUVEsS0FBSyxHQUFHQztnQkFDaEJULFNBQVFVLEtBQUssR0FBR0M7Z0JBRWhCLGdGQUFnRjtnQkFFaEYsSUFBSUMsaUJBQXFCLHVEQUNyQkMsbUJBQXFCLGlEQUNyQkMsZ0JBQXFCLHdCQUNyQkMsaUJBQXFCLGdDQUNyQkMscUJBQXFCO2dCQUV6QixTQUFTUCxXQUFXUSxVQUFVLEVBQUVDLE1BQU07b0JBQ2xDLE9BQU9QLFdBQVdNLFlBQVlFLElBQUksQ0FBQyxTQUFVQyxLQUFLO3dCQUM5QyxJQUFJQyxVQUFVRCxNQUFNQyxPQUFPO3dCQUUzQix1RUFBdUU7d0JBQ3ZFLHFCQUFxQjt3QkFDckIsSUFBSUMsWUFBWUYsTUFBTUcsSUFBSSxLQUFLLFNBQVNMLE9BQU9LLElBQUksS0FBS0gsTUFBTUcsSUFBSTt3QkFFbEUscUVBQXFFO3dCQUNyRSxJQUFJLGFBQWNGLFdBQVksQ0FBRUMsQ0FBQUEsYUFBYUQsT0FBTSxHQUFJOzRCQUNuRCxPQUFPO3dCQUNYO3dCQUVBLElBQUlHLG1CQUFtQkosTUFBTUssV0FBVyxDQUFDQyxLQUFLLENBQUMsU0FBVUMsVUFBVTs0QkFDL0QsSUFBSUMsVUFBV0QsV0FBV0MsT0FBTyxFQUM3QkMsV0FBV0YsV0FB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R0FBSSxVQUFVO1FBQ3BCLE1BQU0sR0FBSSx1Q0FBdUM7UUFDakQsTUFBTSxHQUFJLDBFQUEwRTtRQUNwRixNQUFNLEdBQUksSUFBSW9CLDBCQUFtQkEsR0FBR0MsZ0NBQW1CQSxDQUFDO1FBQ3hELE1BQU0sR0FDTixNQUFNLEdBQUksT0FBT0QsMEJBQW1CQTtJQUNwQyxNQUFNLEdBQUc7QUFFVCxJQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL3Ntcy13ZWIvLi9ub2RlX21vZHVsZXMvcmVhY3QtcmVzcG9uc2l2ZS9kaXN0L3JlYWN0LXJlc3BvbnNpdmUuanM/MjUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXCJyZWFjdFwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJNZWRpYVF1ZXJ5XCJdID0gZmFjdG9yeShyZXF1aXJlKFwicmVhY3RcIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcIk1lZGlhUXVlcnlcIl0gPSBmYWN0b3J5KHJvb3RbXCJSZWFjdFwiXSk7XG59KSh0aGlzLCAoX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV9yZWFjdF9fKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvY3NzLW1lZGlhcXVlcnkvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvY3NzLW1lZGlhcXVlcnkvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuLypcbkNvcHlyaWdodCAoYykgMjAxNCwgWWFob28hIEluYy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbkNvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS5cblNlZSB0aGUgYWNjb21wYW55aW5nIExJQ0VOU0UgZmlsZSBmb3IgdGVybXMuXG4qL1xuXG5cblxuZXhwb3J0cy5tYXRjaCA9IG1hdGNoUXVlcnk7XG5leHBvcnRzLnBhcnNlID0gcGFyc2VRdWVyeTtcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIFJFX01FRElBX1FVRVJZICAgICA9IC8oPzoob25seXxub3QpP1xccyooW15cXHNcXChcXCldKykoPzpcXHMqYW5kKT9cXHMqKT8oLispPy9pLFxuICAgIFJFX01RX0VYUFJFU1NJT04gICA9IC9cXChcXHMqKFteXFxzXFw6XFwpXSspXFxzKig/OlxcOlxccyooW15cXHNcXCldKykpP1xccypcXCkvLFxuICAgIFJFX01RX0ZFQVRVUkUgICAgICA9IC9eKD86KG1pbnxtYXgpLSk/KC4rKS8sXG4gICAgUkVfTEVOR1RIX1VOSVQgICAgID0gLyhlbXxyZW18cHh8Y218bW18aW58cHR8cGMpPyQvLFxuICAgIFJFX1JFU09MVVRJT05fVU5JVCA9IC8oZHBpfGRwY218ZHBweCk/JC87XG5cbmZ1bmN0aW9uIG1hdGNoUXVlcnkobWVkaWFRdWVyeSwgdmFsdWVzKSB7XG4gICAgcmV0dXJuIHBhcnNlUXVlcnkobWVkaWFRdWVyeSkuc29tZShmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIGludmVyc2UgPSBxdWVyeS5pbnZlcnNlO1xuXG4gICAgICAgIC8vIEVpdGhlciB0aGUgcGFyc2VkIG9yIHNwZWNpZmllZCBgdHlwZWAgaXMgXCJhbGxcIiwgb3IgdGhlIHR5cGVzIG11c3QgYmVcbiAgICAgICAgLy8gZXF1YWwgZm9yIGEgbWF0Y2guXG4gICAgICAgIHZhciB0eXBlTWF0Y2ggPSBxdWVyeS50eXBlID09PSAnYWxsJyB8fCB2YWx1ZXMudHlwZSA9PT0gcXVlcnkudHlwZTtcblxuICAgICAgICAvLyBRdWl0IGVhcmx5IHdoZW4gYHR5cGVgIGRvZXNuJ3QgbWF0Y2gsIGJ1dCB0YWtlIFwibm90XCIgaW50byBhY2NvdW50LlxuICAgICAgICBpZiAoKHR5cGVNYXRjaCAmJiBpbnZlcnNlKSB8fCAhKHR5cGVNYXRjaCB8fCBpbnZlcnNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGV4cHJlc3Npb25zTWF0Y2ggPSBxdWVyeS5leHByZXNzaW9ucy5ldmVyeShmdW5jdGlvbiAoZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgID0gZXhwcmVzc2lvbi5mZWF0dXJlLFxuICAgICAgICAgICAgICAgIG1vZGlmaWVyID0gZXhwcmVzc2lvbi5tb2RpZmllcixcbiAgICAgICAgICAgICAgICBleHBWYWx1ZSA9IGV4cHJlc3Npb24udmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWUgICAgPSB2YWx1ZXNbZmVhdHVyZV07XG5cbiAgICAgICAgICAgIC8vIE1pc3Npbmcgb3IgZmFsc3kgdmFsdWVzIGRvbid0IG1hdGNoLlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICAgICAgc3dpdGNoIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3JpZW50YXRpb24nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ3NjYW4nOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gZXhwVmFsdWUudG9Mb3dlckNhc2UoKTtcblxuICAgICAgICAgICAgICAgIGNhc2UgJ3dpZHRoJzpcbiAgICAgICAgICAgICAgICBjYXNlICdoZWlnaHQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RldmljZS13aWR0aCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGV2aWNlLWhlaWdodCc6XG4gICAgICAgICAgICAgICAgICAgIGV4cFZhbHVlID0gdG9QeChleHBWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgID0gdG9QeCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAncmVzb2x1dGlvbic6XG4gICAgICAgICAgICAgICAgICAgIGV4cFZhbHVlID0gdG9EcGkoZXhwVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICA9IHRvRHBpKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdhc3BlY3QtcmF0aW8nOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RldmljZS1hc3BlY3QtcmF0aW8nOlxuICAgICAgICAgICAgICAgIGNhc2UgLyogRGVwcmVjYXRlZCAqLyAnZGV2aWNlLXBpeGVsLXJhdGlvJzpcbiAgICAgICAgICAgICAgICAgICAgZXhwVmFsdWUgPSB0b0RlY2ltYWwoZXhwVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAgICA9IHRvRGVjaW1hbCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnZ3JpZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29sb3InOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbG9yLWluZGV4JzpcbiAgICAgICAgICAgICAgICBjYXNlICdtb25vY2hyb21lJzpcbiAgICAgICAgICAgICAgICAgICAgZXhwVmFsdWUgPSBwYXJzZUludChleHBWYWx1ZSwgMTApIHx8IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICAgID0gcGFyc2VJbnQodmFsdWUsIDEwKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3dpdGNoIChtb2RpZmllcikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbic6IHJldHVybiB2YWx1ZSA+PSBleHBWYWx1ZTtcbiAgICAgICAgICAgICAgICBjYXNlICdtYXgnOiByZXR1cm4gdmFsdWUgPD0gZXhwVmFsdWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdCAgIDogcmV0dXJuIHZhbHVlID09PSBleHBWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIChleHByZXNzaW9uc01hdGNoICYmICFpbnZlcnNlKSB8fCAoIWV4cHJlc3Npb25zTWF0Y2ggJiYgaW52ZXJzZSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUXVlcnkobWVkaWFRdWVyeSkge1xuICAgIHJldHVybiBtZWRpYVF1ZXJ5LnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChxdWVyeSkge1xuICAgICAgICBxdWVyeSA9IHF1ZXJ5LnRyaW0oKTtcblxuICAgICAgICB2YXIgY2FwdHVyZXMgICAgPSBxdWVyeS5tYXRjaChSRV9NRURJQV9RVUVSWSksXG4gICAgICAgICAgICBtb2RpZmllciAgICA9IGNhcHR1cmVzWzFdLFxuICAgICAgICAgICAgdHlwZSAgICAgICAgPSBjYXB0dXJlc1syXSxcbiAgICAgICAgICAgIGV4cHJlc3Npb25zID0gY2FwdHVyZXNbM10gfHwgJycsXG4gICAgICAgICAgICBwYXJzZWQgICAgICA9IHt9O1xuXG4gICAgICAgIHBhcnNlZC5pbnZlcnNlID0gISFtb2RpZmllciAmJiBtb2RpZmllci50b0xvd2VyQ2FzZSgpID09PSAnbm90JztcbiAgICAgICAgcGFyc2VkLnR5cGUgICAgPSB0eXBlID8gdHlwZS50b0xvd2VyQ2FzZSgpIDogJ2FsbCc7XG5cbiAgICAgICAgLy8gU3BsaXQgZXhwcmVzc2lvbnMgaW50byBhIGxpc3QuXG4gICAgICAgIGV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMubWF0Y2goL1xcKFteXFwpXStcXCkvZykgfHwgW107XG5cbiAgICAgICAgcGFyc2VkLmV4cHJlc3Npb25zID0gZXhwcmVzc2lvbnMubWFwKGZ1bmN0aW9uIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgICB2YXIgY2FwdHVyZXMgPSBleHByZXNzaW9uLm1hdGNoKFJFX01RX0VYUFJFU1NJT04pLFxuICAgICAgICAgICAgICAgIGZlYXR1cmUgID0gY2FwdHVyZXNbMV0udG9Mb3dlckNhc2UoKS5tYXRjaChSRV9NUV9GRUFUVVJFKTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtb2RpZmllcjogZmVhdHVyZVsxXSxcbiAgICAgICAgICAgICAgICBmZWF0dXJlIDogZmVhdHVyZVsyXSxcbiAgICAgICAgICAgICAgICB2YWx1ZSAgIDogY2FwdHVyZXNbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfSk7XG59XG5cbi8vIC0tIFV0aWxpdGllcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbmZ1bmN0aW9uIHRvRGVjaW1hbChyYXRpbykge1xuICAgIHZhciBkZWNpbWFsID0gTnVtYmVyKHJhdGlvKSxcbiAgICAgICAgbnVtYmVycztcblxuICAgIGlmICghZGVjaW1hbCkge1xuICAgICAgICBudW1iZXJzID0gcmF0aW8ubWF0Y2goL14oXFxkKylcXHMqXFwvXFxzKihcXGQrKSQvKTtcbiAgICAgICAgZGVjaW1hbCA9IG51bWJlcnNbMV0gLyBudW1iZXJzWzJdO1xuICAgIH1cblxuICAgIHJldHVybiBkZWNpbWFsO1xufVxuXG5mdW5jdGlvbiB0b0RwaShyZXNvbHV0aW9uKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdChyZXNvbHV0aW9uKSxcbiAgICAgICAgdW5pdHMgPSBTdHJpbmcocmVzb2x1dGlvbikubWF0Y2goUkVfUkVTT0xVVElPTl9VTklUKVsxXTtcblxuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAnZHBjbSc6IHJldHVybiB2YWx1ZSAvIDIuNTQ7XG4gICAgICAgIGNhc2UgJ2RwcHgnOiByZXR1cm4gdmFsdWUgKiA5NjtcbiAgICAgICAgZGVmYXVsdCAgICA6IHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHRvUHgobGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gcGFyc2VGbG9hdChsZW5ndGgpLFxuICAgICAgICB1bml0cyA9IFN0cmluZyhsZW5ndGgpLm1hdGNoKFJFX0xFTkdUSF9VTklUKVsxXTtcblxuICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgY2FzZSAnZW0nIDogcmV0dXJuIHZhbHVlICogMTY7XG4gICAgICAgIGNhc2UgJ3JlbSc6IHJldHVybiB2YWx1ZSAqIDE2O1xuICAgICAgICBjYXNlICdjbScgOiByZXR1cm4gdmFsdWUgKiA5NiAvIDIuNTQ7XG4gICAgICAgIGNhc2UgJ21tJyA6IHJldHVybiB2YWx1ZSAqIDk2IC8gMi41NCAvIDEwO1xuICAgICAgICBjYXNlICdpbicgOiByZXR1cm4gdmFsdWUgKiA5NjtcbiAgICAgICAgY2FzZSAncHQnIDogcmV0dXJuIHZhbHVlICogNzI7XG4gICAgICAgIGNhc2UgJ3BjJyA6IHJldHVybiB2YWx1ZSAqIDcyIC8gMTI7XG4gICAgICAgIGRlZmF1bHQgICA6IHJldHVybiB2YWx1ZTtcbiAgICB9XG59XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvaHlwaGVuYXRlLXN0eWxlLW5hbWUvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvaHlwaGVuYXRlLXN0eWxlLW5hbWUvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXCJkZWZhdWx0XCI6ICgpID0+IChfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXylcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdmFyLCBwcmVmZXItdGVtcGxhdGUgKi9cbnZhciB1cHBlcmNhc2VQYXR0ZXJuID0gL1tBLVpdL2dcbnZhciBtc1BhdHRlcm4gPSAvXm1zLS9cbnZhciBjYWNoZSA9IHt9XG5cbmZ1bmN0aW9uIHRvSHlwaGVuTG93ZXIobWF0Y2gpIHtcbiAgcmV0dXJuICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKG5hbWUpIHtcbiAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgcmV0dXJuIGNhY2hlW25hbWVdXG4gIH1cblxuICB2YXIgaE5hbWUgPSBuYW1lLnJlcGxhY2UodXBwZXJjYXNlUGF0dGVybiwgdG9IeXBoZW5Mb3dlcilcbiAgcmV0dXJuIChjYWNoZVtuYW1lXSA9IG1zUGF0dGVybi50ZXN0KGhOYW1lKSA/ICctJyArIGhOYW1lIDogaE5hbWUpXG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gY29uc3QgX19XRUJQQUNLX0RFRkFVTFRfRVhQT1JUX18gPSAoaHlwaGVuYXRlU3R5bGVOYW1lKTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9tYXRjaG1lZGlhcXVlcnkvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL21hdGNobWVkaWFxdWVyeS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBzdGF0aWNNYXRjaCA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjc3MtbWVkaWFxdWVyeSAqLyBcIi4vbm9kZV9tb2R1bGVzL2Nzcy1tZWRpYXF1ZXJ5L2luZGV4LmpzXCIpLm1hdGNoKTtcbnZhciBkeW5hbWljTWF0Y2ggPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdy5tYXRjaE1lZGlhIDogbnVsbDtcblxuLy8gb3VyIGZha2UgTWVkaWFRdWVyeUxpc3RcbmZ1bmN0aW9uIE1xbChxdWVyeSwgdmFsdWVzLCBmb3JjZVN0YXRpYyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYoZHluYW1pY01hdGNoICYmICFmb3JjZVN0YXRpYyl7XG4gICAgdmFyIG1xbCA9IGR5bmFtaWNNYXRjaC5jYWxsKHdpbmRvdywgcXVlcnkpO1xuICAgIHRoaXMubWF0Y2hlcyA9IG1xbC5tYXRjaGVzO1xuICAgIHRoaXMubWVkaWEgPSBtcWwubWVkaWE7XG4gICAgLy8gVE9ETzogaXMgdGhlcmUgYSB0aW1lIGl0IG1ha2VzIHNlbnNlIHRvIHJlbW92ZSB0aGlzIGxpc3RlbmVyP1xuICAgIG1xbC5hZGRMaXN0ZW5lcih1cGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubWF0Y2hlcyA9IHN0YXRpY01hdGNoKHF1ZXJ5LCB2YWx1ZXMpO1xuICAgIHRoaXMubWVkaWEgPSBxdWVyeTtcbiAgfVxuXG4gIHRoaXMuYWRkTGlzdGVuZXIgPSBhZGRMaXN0ZW5lcjtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lciA9IHJlbW92ZUxpc3RlbmVyO1xuICB0aGlzLmRpc3Bvc2UgPSBkaXNwb3NlO1xuXG4gIGZ1bmN0aW9uIGFkZExpc3RlbmVyKGxpc3RlbmVyKXtcbiAgICBpZihtcWwpe1xuICAgICAgbXFsLmFkZExpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcil7XG4gICAgaWYobXFsKXtcbiAgICAgIG1xbC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIG91cnNlbHZlcyFcbiAgZnVuY3Rpb24gdXBkYXRlKGV2dCl7XG4gICAgc2VsZi5tYXRjaGVzID0gZXZ0Lm1hdGNoZXM7XG4gICAgc2VsZi5tZWRpYSA9IGV2dC5tZWRpYTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRpc3Bvc2UoKXtcbiAgICBpZihtcWwpe1xuICAgICAgbXFsLnJlbW92ZUxpc3RlbmVyKHVwZGF0ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoTWVkaWEocXVlcnksIHZhbHVlcywgZm9yY2VTdGF0aWMpe1xuICByZXR1cm4gbmV3IE1xbChxdWVyeSwgdmFsdWVzLCBmb3JjZVN0YXRpYyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2hNZWRpYTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuXG52YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24oKSB7fTtcblxuaWYgKHRydWUpIHtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1wiKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuICB2YXIgaGFzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvaGFzICovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzXCIpO1xuXG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7IC8qKi8gfVxuICB9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAodHJ1ZSkge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcihcbiAgICAgICAgICAgICAgKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICtcbiAgICAgICAgICAgICAgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArXG4gICAgICAgICAgICAgICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgIShlcnJvciBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICcgK1xuICAgICAgICAgICAgbG9jYXRpb24gKyAnIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICtcbiAgICAgICAgICAgICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAnICsgdHlwZW9mIGVycm9yICsgJy4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArXG4gICAgICAgICAgICAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICtcbiAgICAgICAgICAgICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdGYWlsZWQgJyArIGxvY2F0aW9uICsgJyB0eXBlOiAnICsgZXJyb3IubWVzc2FnZSArIChzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmVzZXRzIHdhcm5pbmcgY2FjaGUgd2hlbiB0ZXN0aW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmNoZWNrUHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0cnVlKSB7XG4gICAgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFR5cGVDaGVja2Vycy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5cbnZhciBSZWFjdElzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcmVhY3QtaXMgKi8gXCIuL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qc1wiKTtcbnZhciBhc3NpZ24gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBvYmplY3QtYXNzaWduICovIFwiLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qc1wiKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQgKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldC5qc1wiKTtcbnZhciBoYXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi9oYXMgKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2xpYi9oYXMuanNcIik7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NoZWNrUHJvcFR5cGVzICovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qc1wiKTtcblxudmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmICh0cnVlKSB7XG4gIHByaW50V2FybmluZyA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgdGV4dDtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKCkge1xuICByZXR1cm4gbnVsbDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJpZ2ludDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2JpZ2ludCcpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGVsZW1lbnRUeXBlOiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhICYmIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyA/IGRhdGE6IHt9O1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0gZWxzZSBpZiAoIHRydWUgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBwcm9wIG9uIGAnICsgY29tcG9uZW50TmFtZSArICdgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSxcbiAgICAgICAgICB7ZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGV9XG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uVGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZVR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghUmVhY3RJcy5pc1ZhbGlkRWxlbWVudFR5cGUocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQgdHlwZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByaW50V2FybmluZyhcbiAgICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50cyBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gYXJyYXksIGdvdCAnICsgYXJndW1lbnRzLmxlbmd0aCArICcgYXJndW1lbnRzLiAnICtcbiAgICAgICAgICAgICdBIGNvbW1vbiBtaXN0YWtlIGlzIHRvIHdyaXRlIG9uZU9mKHgsIHksIHopIGluc3RlYWQgb2Ygb25lT2YoW3gsIHksIHpdKS4nXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGFycmF5LicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcywgZnVuY3Rpb24gcmVwbGFjZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgU3RyaW5nKHByb3BWYWx1ZSkgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKGhhcyhwcm9wVmFsdWUsIGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgIHRydWUgPyBwcmludFdhcm5pbmcoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwcmludFdhcm5pbmcoXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJyArIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSArICcgYXQgaW5kZXggJyArIGkgKyAnLidcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb25UaGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgdmFyIGNoZWNrZXJSZXN1bHQgPSBjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoY2hlY2tlclJlc3VsdCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoZWNrZXJSZXN1bHQuZGF0YSAmJiBoYXMoY2hlY2tlclJlc3VsdC5kYXRhLCAnZXhwZWN0ZWRUeXBlJykpIHtcbiAgICAgICAgICBleHBlY3RlZFR5cGVzLnB1c2goY2hlY2tlclJlc3VsdC5kYXRhLmV4cGVjdGVkVHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBleHBlY3RlZFR5cGVzTWVzc2FnZSA9IChleHBlY3RlZFR5cGVzLmxlbmd0aCA+IDApID8gJywgZXhwZWN0ZWQgb25lIG9mIHR5cGUgWycgKyBleHBlY3RlZFR5cGVzLmpvaW4oJywgJykgKyAnXSc6ICcnO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCcgKyBleHBlY3RlZFR5cGVzTWVzc2FnZSArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW52YWxpZFZhbGlkYXRvckVycm9yKGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIGtleSwgdHlwZSkge1xuICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgIChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5ICsgJ2AgaXMgaW52YWxpZDsgJyArXG4gICAgICAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlICsgJ2AuJ1xuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludmFsaWRWYWxpZGF0b3JFcnJvcihjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBrZXksIGdldFByZWNpc2VUeXBlKGNoZWNrZXIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbSBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmIChoYXMoc2hhcGVUeXBlcywga2V5KSAmJiB0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnZhbGlkVmFsaWRhdG9yRXJyb3IoY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwga2V5LCBnZXRQcmVjaXNlVHlwZShjaGVja2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gZmFsc3kgdmFsdWUgY2FuJ3QgYmUgYSBTeW1ib2xcbiAgICBpZiAoIXByb3BWYWx1ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLnJlc2V0V2FybmluZ0NhY2hlID0gY2hlY2tQcm9wVHlwZXMucmVzZXRXYXJuaW5nQ2FjaGU7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAodHJ1ZSkge1xuICB2YXIgUmVhY3RJcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIHJlYWN0LWlzICovIFwiLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvaW5kZXguanNcIik7XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMgKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzXCIpKFJlYWN0SXMuaXNFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7fVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblxuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL2hhcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvaGFzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvcmVhY3QtaXMvY2pzL3JlYWN0LWlzLmRldmVsb3BtZW50LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEzLjFcbiAqIHJlYWN0LWlzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBGYWNlYm9vaywgSW5jLiBhbmQgaXRzIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXG5cblxuXG5pZiAodHJ1ZSkge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgaGFzU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuZm9yO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSA6IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpIDogMHhlYWNhO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpIDogMHhlYWNiO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpIDogMHhlYWNjO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpIDogMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpIDogMHhlYWNkO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKSA6IDB4ZWFjZTsgLy8gVE9ETzogV2UgZG9uJ3QgdXNlIEFzeW5jTW9kZSBvciBDb25jdXJyZW50TW9kZSBhbnltb3JlLiBUaGV5IHdlcmUgdGVtcG9yYXJ5XG4vLyAodW5zdGFibGUpIEFQSXMgdGhhdCBoYXZlIGJlZW4gcmVtb3ZlZC4gQ2FuIHdlIHJlbW92ZSB0aGUgc3ltYm9scz9cblxudmFyIFJFQUNUX0FTWU5DX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmFzeW5jX21vZGUnKSA6IDB4ZWFjZjtcbnZhciBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbmN1cnJlbnRfbW9kZScpIDogMHhlYWNmO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpIDogMHhlYWQwO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpIDogMHhlYWQxO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKSA6IDB4ZWFkODtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJykgOiAweGVhZDM7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QubGF6eScpIDogMHhlYWQ0O1xudmFyIFJFQUNUX0JMT0NLX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5ibG9jaycpIDogMHhlYWQ5O1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5mdW5kYW1lbnRhbCcpIDogMHhlYWQ1O1xudmFyIFJFQUNUX1JFU1BPTkRFUl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sLmZvcigncmVhY3QucmVzcG9uZGVyJykgOiAweGVhZDY7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IGhhc1N5bWJvbCA/IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJykgOiAweGVhZDc7XG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgLy8gTm90ZTogaXRzIHR5cGVvZiBtaWdodCBiZSBvdGhlciB0aGFuICdzeW1ib2wnIG9yICdudW1iZXInIGlmIGl0J3MgYSBwb2x5ZmlsbC5cbiAgdHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfUFJPVklERVJfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1JFU1BPTkRFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1NDT1BFX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQkxPQ0tfVFlQRSk7XG59XG5cbmZ1bmN0aW9uIHR5cGVPZihvYmplY3QpIHtcbiAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IG9iamVjdC4kJHR5cGVvZjtcblxuICAgIHN3aXRjaCAoJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICB2YXIgdHlwZSA9IG9iamVjdC50eXBlO1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQVNZTkNfTU9ERV9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdmFyICQkdHlwZW9mVHlwZSA9IHR5cGUgJiYgdHlwZS4kJHR5cGVvZjtcblxuICAgICAgICAgICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgICAgcmV0dXJuICQkdHlwZW9mVHlwZTtcblxuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgIHJldHVybiAkJHR5cGVvZjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdW5kZWZpbmVkO1xufSAvLyBBc3luY01vZGUgaXMgZGVwcmVjYXRlZCBhbG9uZyB3aXRoIGlzQXN5bmNNb2RlXG5cbnZhciBBc3luY01vZGUgPSBSRUFDVF9BU1lOQ19NT0RFX1RZUEU7XG52YXIgQ29uY3VycmVudE1vZGUgPSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSBSRUFDVF9DT05URVhUX1RZUEU7XG52YXIgQ29udGV4dFByb3ZpZGVyID0gUkVBQ1RfUFJPVklERVJfVFlQRTtcbnZhciBFbGVtZW50ID0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIEZvcndhcmRSZWYgPSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFO1xudmFyIEZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbnZhciBMYXp5ID0gUkVBQ1RfTEFaWV9UWVBFO1xudmFyIE1lbW8gPSBSRUFDVF9NRU1PX1RZUEU7XG52YXIgUG9ydGFsID0gUkVBQ1RfUE9SVEFMX1RZUEU7XG52YXIgUHJvZmlsZXIgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xudmFyIFN0cmljdE1vZGUgPSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFO1xudmFyIFN1c3BlbnNlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbnZhciBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IGZhbHNlOyAvLyBBc3luY01vZGUgc2hvdWxkIGJlIGRlcHJlY2F0ZWRcblxuZnVuY3Rpb24gaXNBc3luY01vZGUob2JqZWN0KSB7XG4gIHtcbiAgICBpZiAoIWhhc1dhcm5lZEFib3V0RGVwcmVjYXRlZElzQXN5bmNNb2RlKSB7XG4gICAgICBoYXNXYXJuZWRBYm91dERlcHJlY2F0ZWRJc0FzeW5jTW9kZSA9IHRydWU7IC8vIFVzaW5nIGNvbnNvbGVbJ3dhcm4nXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnVGhlIFJlYWN0SXMuaXNBc3luY01vZGUoKSBhbGlhcyBoYXMgYmVlbiBkZXByZWNhdGVkLCAnICsgJ2FuZCB3aWxsIGJlIHJlbW92ZWQgaW4gUmVhY3QgMTcrLiBVcGRhdGUgeW91ciBjb2RlIHRvIHVzZSAnICsgJ1JlYWN0SXMuaXNDb25jdXJyZW50TW9kZSgpIGluc3RlYWQuIEl0IGhhcyB0aGUgZXhhY3Qgc2FtZSBBUEkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGlzQ29uY3VycmVudE1vZGUob2JqZWN0KSB8fCB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfQVNZTkNfTU9ERV9UWVBFO1xufVxuZnVuY3Rpb24gaXNDb25jdXJyZW50TW9kZShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9DT05DVVJSRU5UX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST1ZJREVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc0VsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG59XG5mdW5jdGlvbiBpc0ZvcndhcmRSZWYob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzRnJhZ21lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzTGF6eShvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVPZihvYmplY3QpID09PSBSRUFDVF9MQVpZX1RZUEU7XG59XG5mdW5jdGlvbiBpc01lbW8ob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfTUVNT19UWVBFO1xufVxuZnVuY3Rpb24gaXNQb3J0YWwob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfUE9SVEFMX1RZUEU7XG59XG5mdW5jdGlvbiBpc1Byb2ZpbGVyKG9iamVjdCkge1xuICByZXR1cm4gdHlwZU9mKG9iamVjdCkgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG59XG5mdW5jdGlvbiBpc1N0cmljdE1vZGUob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbn1cbmZ1bmN0aW9uIGlzU3VzcGVuc2Uob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlT2Yob2JqZWN0KSA9PT0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbn1cblxuZXhwb3J0cy5Bc3luY01vZGUgPSBBc3luY01vZGU7XG5leHBvcnRzLkNvbmN1cnJlbnRNb2RlID0gQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLkNvbnRleHRDb25zdW1lciA9IENvbnRleHRDb25zdW1lcjtcbmV4cG9ydHMuQ29udGV4dFByb3ZpZGVyID0gQ29udGV4dFByb3ZpZGVyO1xuZXhwb3J0cy5FbGVtZW50ID0gRWxlbWVudDtcbmV4cG9ydHMuRm9yd2FyZFJlZiA9IEZvcndhcmRSZWY7XG5leHBvcnRzLkZyYWdtZW50ID0gRnJhZ21lbnQ7XG5leHBvcnRzLkxhenkgPSBMYXp5O1xuZXhwb3J0cy5NZW1vID0gTWVtbztcbmV4cG9ydHMuUG9ydGFsID0gUG9ydGFsO1xuZXhwb3J0cy5Qcm9maWxlciA9IFByb2ZpbGVyO1xuZXhwb3J0cy5TdHJpY3RNb2RlID0gU3RyaWN0TW9kZTtcbmV4cG9ydHMuU3VzcGVuc2UgPSBTdXNwZW5zZTtcbmV4cG9ydHMuaXNBc3luY01vZGUgPSBpc0FzeW5jTW9kZTtcbmV4cG9ydHMuaXNDb25jdXJyZW50TW9kZSA9IGlzQ29uY3VycmVudE1vZGU7XG5leHBvcnRzLmlzQ29udGV4dENvbnN1bWVyID0gaXNDb250ZXh0Q29uc3VtZXI7XG5leHBvcnRzLmlzQ29udGV4dFByb3ZpZGVyID0gaXNDb250ZXh0UHJvdmlkZXI7XG5leHBvcnRzLmlzRWxlbWVudCA9IGlzRWxlbWVudDtcbmV4cG9ydHMuaXNGb3J3YXJkUmVmID0gaXNGb3J3YXJkUmVmO1xuZXhwb3J0cy5pc0ZyYWdtZW50ID0gaXNGcmFnbWVudDtcbmV4cG9ydHMuaXNMYXp5ID0gaXNMYXp5O1xuZXhwb3J0cy5pc01lbW8gPSBpc01lbW87XG5leHBvcnRzLmlzUG9ydGFsID0gaXNQb3J0YWw7XG5leHBvcnRzLmlzUHJvZmlsZXIgPSBpc1Byb2ZpbGVyO1xuZXhwb3J0cy5pc1N0cmljdE1vZGUgPSBpc1N0cmljdE1vZGU7XG5leHBvcnRzLmlzU3VzcGVuc2UgPSBpc1N1c3BlbnNlO1xuZXhwb3J0cy5pc1ZhbGlkRWxlbWVudFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGU7XG5leHBvcnRzLnR5cGVPZiA9IHR5cGVPZjtcbiAgfSkoKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL25vZGVfbW9kdWxlcy9yZWFjdC1pcy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuaWYgKGZhbHNlKSB7fSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qcyAqLyBcIi4vbm9kZV9tb2R1bGVzL3JlYWN0LWlzL2Nqcy9yZWFjdC1pcy5kZXZlbG9wbWVudC5qc1wiKTtcbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL25vZGVfbW9kdWxlcy9zaGFsbG93LWVxdWFsL2Rpc3QvaW5kZXguZXNtLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9ub2RlX21vZHVsZXMvc2hhbGxvdy1lcXVhbC9kaXN0L2luZGV4LmVzbS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwic2hhbGxvd0VxdWFsQXJyYXlzXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHNoYWxsb3dFcXVhbEFycmF5cyksXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFwic2hhbGxvd0VxdWFsT2JqZWN0c1wiOiAoKSA9PiAoLyogYmluZGluZyAqLyBzaGFsbG93RXF1YWxPYmplY3RzKVxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XG5mdW5jdGlvbiBzaGFsbG93RXF1YWxPYmplY3RzKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghb2JqQSB8fCAhb2JqQikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBhS2V5cyA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIgYktleXMgPSBPYmplY3Qua2V5cyhvYmpCKTtcbiAgdmFyIGxlbiA9IGFLZXlzLmxlbmd0aDtcblxuICBpZiAoYktleXMubGVuZ3RoICE9PSBsZW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGFLZXlzW2ldO1xuXG4gICAgaWYgKG9iakFba2V5XSAhPT0gb2JqQltrZXldIHx8ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWxBcnJheXMoYXJyQSwgYXJyQikge1xuICBpZiAoYXJyQSA9PT0gYXJyQikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKCFhcnJBIHx8ICFhcnJCKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGxlbiA9IGFyckEubGVuZ3RoO1xuXG4gIGlmIChhcnJCLmxlbmd0aCAhPT0gbGVuKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChhcnJBW2ldICE9PSBhcnJCW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cblxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL0NvbXBvbmVudC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvQ29tcG9uZW50LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG52YXIgdXNlTWVkaWFRdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXNlTWVkaWFRdWVyeSAqLyBcIi4vc3JjL3VzZU1lZGlhUXVlcnkudHNcIikpO1xuLy8gUmVhY3ROb2RlIGFuZCBSZWFjdEVsZW1lbnQgdHlwaW5ncyBhcmUgYSBsaXR0bGUgZnVua3kgZm9yIGZ1bmN0aW9uYWwgY29tcG9uZW50cywgc28gdGhlIFJlYWN0RWxlbWVudCBjYXN0IGlzIG5lZWRlZCBvbiB0aGUgcmV0dXJuXG52YXIgTWVkaWFRdWVyeSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBkZXZpY2UgPSBfYS5kZXZpY2UsIG9uQ2hhbmdlID0gX2Eub25DaGFuZ2UsIHNldHRpbmdzID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImRldmljZVwiLCBcIm9uQ2hhbmdlXCJdKTtcbiAgICB2YXIgbWF0Y2hlcyA9ICgwLCB1c2VNZWRpYVF1ZXJ5XzEuZGVmYXVsdCkoc2V0dGluZ3MsIGRldmljZSwgb25DaGFuZ2UpO1xuICAgIGlmICh0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuKG1hdGNoZXMpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0Y2hlcyA/IGNoaWxkcmVuIDogbnVsbDtcbn07XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IE1lZGlhUXVlcnk7XG5cblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9zcmMvQ29udGV4dC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL0NvbnRleHQudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xudmFyIHJlYWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWFjdCAqLyBcInJlYWN0XCIpO1xudmFyIENvbnRleHQgPSAoMCwgcmVhY3RfMS5jcmVhdGVDb250ZXh0KSh1bmRlZmluZWQpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBDb250ZXh0O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vc3JjL2luZGV4LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbmV4cG9ydHMuQ29udGV4dCA9IGV4cG9ydHMudG9RdWVyeSA9IGV4cG9ydHMudXNlTWVkaWFRdWVyeSA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIHVzZU1lZGlhUXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3VzZU1lZGlhUXVlcnkgKi8gXCIuL3NyYy91c2VNZWRpYVF1ZXJ5LnRzXCIpKTtcbmV4cG9ydHMudXNlTWVkaWFRdWVyeSA9IHVzZU1lZGlhUXVlcnlfMS5kZWZhdWx0O1xudmFyIENvbXBvbmVudF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQ29tcG9uZW50ICovIFwiLi9zcmMvQ29tcG9uZW50LnRzXCIpKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29tcG9uZW50XzEuZGVmYXVsdDtcbnZhciB0b1F1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b1F1ZXJ5ICovIFwiLi9zcmMvdG9RdWVyeS50c1wiKSk7XG5leHBvcnRzLnRvUXVlcnkgPSB0b1F1ZXJ5XzEuZGVmYXVsdDtcbnZhciBDb250ZXh0XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9Db250ZXh0ICovIFwiLi9zcmMvQ29udGV4dC50c1wiKSk7XG5leHBvcnRzLkNvbnRleHQgPSBDb250ZXh0XzEuZGVmYXVsdDtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy9tZWRpYVF1ZXJ5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvbWVkaWFRdWVyeS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19hc3NpZ24gPSAodGhpcyAmJiB0aGlzLl9fYXNzaWduKSB8fCBmdW5jdGlvbiAoKSB7XG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKVxuICAgICAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0O1xuICAgIH07XG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoeyB2YWx1ZTogdHJ1ZSB9KSk7XG52YXIgcHJvcF90eXBlc18xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIHByb3AtdHlwZXMgKi8gXCIuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzXCIpKTtcbnZhciBzdHJpbmdPck51bWJlciA9IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mVHlwZShbXG4gICAgcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgIHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlclxuXSk7XG4vLyBtZWRpYSB0eXBlc1xudmFyIHR5cGVzID0ge1xuICAgIGFsbDogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICBncmlkOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIGF1cmFsOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIGJyYWlsbGU6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgaGFuZGhlbGQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgcHJpbnQ6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgcHJvamVjdGlvbjogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICBzY3JlZW46IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgdHR5OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIHR2OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIGVtYm9zc2VkOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sXG59O1xuLy8gcHJvcGVydGllcyB0aGF0IG1hdGNoIG1lZGlhIHF1ZXJpZXNcbnZhciBtYXRjaGVycyA9IHtcbiAgICBvcmllbnRhdGlvbjogcHJvcF90eXBlc18xLmRlZmF1bHQub25lT2YoW1xuICAgICAgICAncG9ydHJhaXQnLFxuICAgICAgICAnbGFuZHNjYXBlJ1xuICAgIF0pLFxuICAgIHNjYW46IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm9uZU9mKFtcbiAgICAgICAgJ3Byb2dyZXNzaXZlJyxcbiAgICAgICAgJ2ludGVybGFjZSdcbiAgICBdKSxcbiAgICBhc3BlY3RSYXRpbzogcHJvcF90eXBlc18xLmRlZmF1bHQuc3RyaW5nLFxuICAgIGRldmljZUFzcGVjdFJhdGlvOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsXG4gICAgaGVpZ2h0OiBzdHJpbmdPck51bWJlcixcbiAgICBkZXZpY2VIZWlnaHQ6IHN0cmluZ09yTnVtYmVyLFxuICAgIHdpZHRoOiBzdHJpbmdPck51bWJlcixcbiAgICBkZXZpY2VXaWR0aDogc3RyaW5nT3JOdW1iZXIsXG4gICAgY29sb3I6IHByb3BfdHlwZXNfMS5kZWZhdWx0LmJvb2wsXG4gICAgY29sb3JJbmRleDogcHJvcF90eXBlc18xLmRlZmF1bHQuYm9vbCxcbiAgICBtb25vY2hyb21lOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5ib29sLFxuICAgIHJlc29sdXRpb246IHN0cmluZ09yTnVtYmVyLFxuICAgIHR5cGU6IE9iamVjdC5rZXlzKHR5cGVzKVxufTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbnZhciB0eXBlID0gbWF0Y2hlcnMudHlwZSwgZmVhdHVyZU1hdGNoZXJzID0gX19yZXN0KG1hdGNoZXJzXG4vLyBtZWRpYSBmZWF0dXJlc1xuLCBbXCJ0eXBlXCJdKTtcbi8vIG1lZGlhIGZlYXR1cmVzXG52YXIgZmVhdHVyZXMgPSBfX2Fzc2lnbih7IG1pbkFzcGVjdFJhdGlvOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsIG1heEFzcGVjdFJhdGlvOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsIG1pbkRldmljZUFzcGVjdFJhdGlvOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsIG1heERldmljZUFzcGVjdFJhdGlvOiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5zdHJpbmcsIG1pbkhlaWdodDogc3RyaW5nT3JOdW1iZXIsIG1heEhlaWdodDogc3RyaW5nT3JOdW1iZXIsIG1pbkRldmljZUhlaWdodDogc3RyaW5nT3JOdW1iZXIsIG1heERldmljZUhlaWdodDogc3RyaW5nT3JOdW1iZXIsIG1pbldpZHRoOiBzdHJpbmdPck51bWJlciwgbWF4V2lkdGg6IHN0cmluZ09yTnVtYmVyLCBtaW5EZXZpY2VXaWR0aDogc3RyaW5nT3JOdW1iZXIsIG1heERldmljZVdpZHRoOiBzdHJpbmdPck51bWJlciwgbWluQ29sb3I6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlciwgbWF4Q29sb3I6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlciwgbWluQ29sb3JJbmRleDogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLCBtYXhDb2xvckluZGV4OiBwcm9wX3R5cGVzXzEuZGVmYXVsdC5udW1iZXIsIG1pbk1vbm9jaHJvbWU6IHByb3BfdHlwZXNfMS5kZWZhdWx0Lm51bWJlciwgbWF4TW9ub2Nocm9tZTogcHJvcF90eXBlc18xLmRlZmF1bHQubnVtYmVyLCBtaW5SZXNvbHV0aW9uOiBzdHJpbmdPck51bWJlciwgbWF4UmVzb2x1dGlvbjogc3RyaW5nT3JOdW1iZXIgfSwgZmVhdHVyZU1hdGNoZXJzKTtcbnZhciBhbGwgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHlwZXMpLCBmZWF0dXJlcyk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHtcbiAgICBhbGw6IGFsbCxcbiAgICB0eXBlczogdHlwZXMsXG4gICAgbWF0Y2hlcnM6IG1hdGNoZXJzLFxuICAgIGZlYXR1cmVzOiBmZWF0dXJlc1xufTtcblxuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3NyYy90b1F1ZXJ5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9zcmMvdG9RdWVyeS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKGZ1bmN0aW9uKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7IHZhbHVlOiB0cnVlIH0pKTtcbnZhciBoeXBoZW5hdGVfc3R5bGVfbmFtZV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIGh5cGhlbmF0ZS1zdHlsZS1uYW1lICovIFwiLi9ub2RlX21vZHVsZXMvaHlwaGVuYXRlLXN0eWxlLW5hbWUvaW5kZXguanNcIikpO1xudmFyIG1lZGlhUXVlcnlfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lZGlhUXVlcnkgKi8gXCIuL3NyYy9tZWRpYVF1ZXJ5LnRzXCIpKTtcbnZhciBuZWdhdGUgPSBmdW5jdGlvbiAoY29uZCkgeyByZXR1cm4gXCJub3QgXCIuY29uY2F0KGNvbmQpOyB9O1xudmFyIGtleVZhbCA9IGZ1bmN0aW9uIChrLCB2KSB7XG4gICAgdmFyIHJlYWxLZXkgPSAoMCwgaHlwaGVuYXRlX3N0eWxlX25hbWVfMS5kZWZhdWx0KShrKTtcbiAgICAvLyBweCBzaG9ydGhhbmRcbiAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHYgPSBcIlwiLmNvbmNhdCh2LCBcInB4XCIpO1xuICAgIH1cbiAgICBpZiAodiA9PT0gdHJ1ZSkge1xuICAgICAgICByZXR1cm4gcmVhbEtleTtcbiAgICB9XG4gICAgaWYgKHYgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZWdhdGUocmVhbEtleSk7XG4gICAgfVxuICAgIHJldHVybiBcIihcIi5jb25jYXQocmVhbEtleSwgXCI6IFwiKS5jb25jYXQodiwgXCIpXCIpO1xufTtcbnZhciBqb2luID0gZnVuY3Rpb24gKGNvbmRzKSB7IHJldHVybiBjb25kcy5qb2luKCcgYW5kICcpOyB9O1xudmFyIHRvUXVlcnkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIHJ1bGVzID0gW107XG4gICAgT2JqZWN0LmtleXMobWVkaWFRdWVyeV8xLmRlZmF1bHQuYWxsKS5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciB2ID0gb2JqW2tdO1xuICAgICAgICBpZiAodiAhPSBudWxsKSB7XG4gICAgICAgICAgICBydWxlcy5wdXNoKGtleVZhbChrLCB2KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gam9pbihydWxlcyk7XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB0b1F1ZXJ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vc3JjL3VzZU1lZGlhUXVlcnkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3NyYy91c2VNZWRpYVF1ZXJ5LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoZnVuY3Rpb24oX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHsgdmFsdWU6IHRydWUgfSkpO1xudmFyIHJlYWN0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISByZWFjdCAqLyBcInJlYWN0XCIpO1xudmFyIG1hdGNobWVkaWFxdWVyeV8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIG1hdGNobWVkaWFxdWVyeSAqLyBcIi4vbm9kZV9tb2R1bGVzL21hdGNobWVkaWFxdWVyeS9pbmRleC5qc1wiKSk7XG52YXIgaHlwaGVuYXRlX3N0eWxlX25hbWVfMSA9IF9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBoeXBoZW5hdGUtc3R5bGUtbmFtZSAqLyBcIi4vbm9kZV9tb2R1bGVzL2h5cGhlbmF0ZS1zdHlsZS1uYW1lL2luZGV4LmpzXCIpKTtcbnZhciBzaGFsbG93X2VxdWFsXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaGFsbG93LWVxdWFsICovIFwiLi9ub2RlX21vZHVsZXMvc2hhbGxvdy1lcXVhbC9kaXN0L2luZGV4LmVzbS5qc1wiKTtcbnZhciB0b1F1ZXJ5XzEgPSBfX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi90b1F1ZXJ5ICovIFwiLi9zcmMvdG9RdWVyeS50c1wiKSk7XG52YXIgQ29udGV4dF8xID0gX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vQ29udGV4dCAqLyBcIi4vc3JjL0NvbnRleHQudHNcIikpO1xudmFyIG1ha2VRdWVyeSA9IGZ1bmN0aW9uIChzZXR0aW5ncykgeyByZXR1cm4gc2V0dGluZ3MucXVlcnkgfHwgKDAsIHRvUXVlcnlfMS5kZWZhdWx0KShzZXR0aW5ncyk7IH07XG52YXIgaHlwaGVuYXRlS2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIW9iailcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgcmV0dXJuIGtleXMucmVkdWNlKGZ1bmN0aW9uIChyZXN1bHQsIGtleSkge1xuICAgICAgICByZXN1bHRbKDAsIGh5cGhlbmF0ZV9zdHlsZV9uYW1lXzEuZGVmYXVsdCkoa2V5KV0gPSBvYmpba2V5XTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG59O1xudmFyIHVzZUlzVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZWYgPSAoMCwgcmVhY3RfMS51c2VSZWYpKGZhbHNlKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gcmVmLmN1cnJlbnQ7XG59O1xudmFyIHVzZURldmljZSA9IGZ1bmN0aW9uIChkZXZpY2VGcm9tUHJvcHMpIHtcbiAgICB2YXIgZGV2aWNlRnJvbUNvbnRleHQgPSAoMCwgcmVhY3RfMS51c2VDb250ZXh0KShDb250ZXh0XzEuZGVmYXVsdCk7XG4gICAgdmFyIGdldERldmljZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGh5cGhlbmF0ZUtleXMoZGV2aWNlRnJvbVByb3BzKSB8fCBoeXBoZW5hdGVLZXlzKGRldmljZUZyb21Db250ZXh0KTtcbiAgICB9O1xuICAgIHZhciBfYSA9ICgwLCByZWFjdF8xLnVzZVN0YXRlKShnZXREZXZpY2UpLCBkZXZpY2UgPSBfYVswXSwgc2V0RGV2aWNlID0gX2FbMV07XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXdEZXZpY2UgPSBnZXREZXZpY2UoKTtcbiAgICAgICAgaWYgKCEoMCwgc2hhbGxvd19lcXVhbF8xLnNoYWxsb3dFcXVhbE9iamVjdHMpKGRldmljZSwgbmV3RGV2aWNlKSkge1xuICAgICAgICAgICAgc2V0RGV2aWNlKG5ld0RldmljZSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGV2aWNlRnJvbVByb3BzLCBkZXZpY2VGcm9tQ29udGV4dF0pO1xuICAgIHJldHVybiBkZXZpY2U7XG59O1xudmFyIHVzZVF1ZXJ5ID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgdmFyIGdldFF1ZXJ5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWFrZVF1ZXJ5KHNldHRpbmdzKTsgfTtcbiAgICB2YXIgX2EgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZ2V0UXVlcnkpLCBxdWVyeSA9IF9hWzBdLCBzZXRRdWVyeSA9IF9hWzFdO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3UXVlcnkgPSBnZXRRdWVyeSgpO1xuICAgICAgICBpZiAocXVlcnkgIT09IG5ld1F1ZXJ5KSB7XG4gICAgICAgICAgICBzZXRRdWVyeShuZXdRdWVyeSk7XG4gICAgICAgIH1cbiAgICB9LCBbc2V0dGluZ3NdKTtcbiAgICByZXR1cm4gcXVlcnk7XG59O1xudmFyIHVzZU1hdGNoTWVkaWEgPSBmdW5jdGlvbiAocXVlcnksIGRldmljZSkge1xuICAgIHZhciBnZXRNYXRjaE1lZGlhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKDAsIG1hdGNobWVkaWFxdWVyeV8xLmRlZmF1bHQpKHF1ZXJ5LCBkZXZpY2UgfHwge30sICEhZGV2aWNlKTsgfTtcbiAgICB2YXIgX2EgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkoZ2V0TWF0Y2hNZWRpYSksIG1xID0gX2FbMF0sIHNldE1xID0gX2FbMV07XG4gICAgdmFyIGlzVXBkYXRlID0gdXNlSXNVcGRhdGUoKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBza2lwIG9uIG1vdW50aW5nLCBpdCBoYXMgYWxyZWFkeSBiZWVuIHNldFxuICAgICAgICAgICAgdmFyIG5ld01xXzEgPSBnZXRNYXRjaE1lZGlhKCk7XG4gICAgICAgICAgICBzZXRNcShuZXdNcV8xKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld01xXzEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TXFfMS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtxdWVyeSwgZGV2aWNlXSk7XG4gICAgcmV0dXJuIG1xO1xufTtcbnZhciB1c2VNYXRjaGVzID0gZnVuY3Rpb24gKG1lZGlhUXVlcnkpIHtcbiAgICB2YXIgX2EgPSAoMCwgcmVhY3RfMS51c2VTdGF0ZSkobWVkaWFRdWVyeS5tYXRjaGVzKSwgbWF0Y2hlcyA9IF9hWzBdLCBzZXRNYXRjaGVzID0gX2FbMV07XG4gICAgKDAsIHJlYWN0XzEudXNlRWZmZWN0KShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB1cGRhdGVNYXRjaGVzID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBzZXRNYXRjaGVzKGV2Lm1hdGNoZXMpO1xuICAgICAgICB9O1xuICAgICAgICBtZWRpYVF1ZXJ5LmFkZExpc3RlbmVyKHVwZGF0ZU1hdGNoZXMpO1xuICAgICAgICBzZXRNYXRjaGVzKG1lZGlhUXVlcnkubWF0Y2hlcyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBtZWRpYVF1ZXJ5LnJlbW92ZUxpc3RlbmVyKHVwZGF0ZU1hdGNoZXMpO1xuICAgICAgICB9O1xuICAgIH0sIFttZWRpYVF1ZXJ5XSk7XG4gICAgcmV0dXJuIG1hdGNoZXM7XG59O1xudmFyIHVzZU1lZGlhUXVlcnkgPSBmdW5jdGlvbiAoc2V0dGluZ3MsIGRldmljZSwgb25DaGFuZ2UpIHtcbiAgICB2YXIgZGV2aWNlU2V0dGluZ3MgPSB1c2VEZXZpY2UoZGV2aWNlKTtcbiAgICB2YXIgcXVlcnkgPSB1c2VRdWVyeShzZXR0aW5ncyk7XG4gICAgaWYgKCFxdWVyeSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG9yIG1pc3NpbmcgTWVkaWFRdWVyeSEnKTtcbiAgICB2YXIgbXEgPSB1c2VNYXRjaE1lZGlhKHF1ZXJ5LCBkZXZpY2VTZXR0aW5ncyk7XG4gICAgdmFyIG1hdGNoZXMgPSB1c2VNYXRjaGVzKG1xKTtcbiAgICB2YXIgaXNVcGRhdGUgPSB1c2VJc1VwZGF0ZSgpO1xuICAgICgwLCByZWFjdF8xLnVzZUVmZmVjdCkoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNVcGRhdGUgJiYgb25DaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKG1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgfSwgW21hdGNoZXNdKTtcbiAgICAoMCwgcmVhY3RfMS51c2VFZmZlY3QpKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG1xKSB7XG4gICAgICAgICAgICBtcS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9OyB9LCBbXSk7XG4gICAgcmV0dXJuIG1hdGNoZXM7XG59O1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB1c2VNZWRpYVF1ZXJ5O1xuXG5cbi8qKiovIH0pLFxuXG4vKioqLyBcInJlYWN0XCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiBleHRlcm5hbCB7XCJjb21tb25qc1wiOlwicmVhY3RcIixcImNvbW1vbmpzMlwiOlwicmVhY3RcIixcImFtZFwiOlwicmVhY3RcIixcInJvb3RcIjpcIlJlYWN0XCJ9ICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX3JlYWN0X187XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuLyoqKioqKi8gXHRcdFx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuLyoqKioqKi8gXHRcdFx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcbi8qKioqKiovIFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuLyoqKioqKi8gXHRcdFx0XHR9XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0fSkoKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpXG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG4vKioqKioqLyBcdFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0XHR9XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyhcIi4vc3JjL2luZGV4LnRzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlYWN0LXJlc3BvbnNpdmUuanMubWFwIl0sIm5hbWVzIjpbIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwicm9vdCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwicmVxdWlyZSIsImRlZmluZSIsImFtZCIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfcmVhY3RfXyIsIl9fd2VicGFja19tb2R1bGVzX18iLCJfX3VudXNlZF93ZWJwYWNrX21vZHVsZSIsIm1hdGNoIiwibWF0Y2hRdWVyeSIsInBhcnNlIiwicGFyc2VRdWVyeSIsIlJFX01FRElBX1FVRVJZIiwiUkVfTVFfRVhQUkVTU0lPTiIsIlJFX01RX0ZFQVRVUkUiLCJSRV9MRU5HVEhfVU5JVCIsIlJFX1JFU09MVVRJT05fVU5JVCIsIm1lZGlhUXVlcnkiLCJ2YWx1ZXMiLCJzb21lIiwicXVlcnkiLCJpbnZlcnNlIiwidHlwZU1hdGNoIiwidHlwZSIsImV4cHJlc3Npb25zTWF0Y2giLCJleHByZXNzaW9ucyIsImV2ZXJ5IiwiZXhwcmVzc2lvbiIsImZlYXR1cmUiLCJtb2RpZmllciIsImV4cFZhbHVlIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInRvUHgiLCJ0b0RwaSIsInRvRGVjaW1hbCIsInBhcnNlSW50Iiwic3BsaXQiLCJtYXAiLCJ0cmltIiwiY2FwdHVyZXMiLCJwYXJzZWQiLCJyYXRpbyIsImRlY2ltYWwiLCJOdW1iZXIiLCJudW1iZXJzIiwicmVzb2x1dGlvbiIsInBhcnNlRmxvYXQiLCJ1bml0cyIsIlN0cmluZyIsImxlbmd0aCIsIl9fd2VicGFja19leHBvcnRzX18iLCJfX3dlYnBhY2tfcmVxdWlyZV9fIiwiciIsImQiLCJfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyIsInVwcGVyY2FzZVBhdHRlcm4iLCJtc1BhdHRlcm4iLCJjYWNoZSIsInRvSHlwaGVuTG93ZXIiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJuYW1lIiwiaGFzT3duUHJvcGVydHkiLCJoTmFtZSIsInJlcGxhY2UiLCJ0ZXN0IiwiX191bnVzZWRfd2VicGFja19leHBvcnRzIiwic3RhdGljTWF0Y2giLCJkeW5hbWljTWF0Y2giLCJ3aW5kb3ciLCJtYXRjaE1lZGlhIiwiTXFsIiwiZm9yY2VTdGF0aWMiLCJzZWxmIiwibXFsIiwiY2FsbCIsIm1hdGNoZXMiLCJtZWRpYSIsImFkZExpc3RlbmVyIiwidXBkYXRlIiwicmVtb3ZlTGlzdGVuZXIiLCJkaXNwb3NlIiwibGlzdGVuZXIiLCJldnQiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsInVuZGVmaW5lZCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsImFzc2lnbiIsInRlc3QxIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiaSIsImZyb21DaGFyQ29kZSIsIm9yZGVyMiIsIm4iLCJqb2luIiwidGVzdDMiLCJmb3JFYWNoIiwibGV0dGVyIiwia2V5cyIsImVyciIsInRhcmdldCIsInNvdXJjZSIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwiYXJndW1lbnRzIiwia2V5IiwicHJpbnRXYXJuaW5nIiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJoYXMiLCJ0ZXh0IiwibWVzc2FnZSIsImNvbnNvbGUiLCJlcnJvciIsIkVycm9yIiwieCIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsInN0YWNrIiwicmVzZXRXYXJuaW5nQ2FjaGUiLCJSZWFjdElzIiwiZW1wdHlGdW5jdGlvblRoYXRSZXR1cm5zTnVsbCIsImlzVmFsaWRFbGVtZW50IiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsIklURVJBVE9SX1NZTUJPTCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJBTk9OWU1PVVMiLCJSZWFjdFByb3BUeXBlcyIsImFycmF5IiwiY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIiLCJiaWdpbnQiLCJib29sIiwiZnVuYyIsIm51bWJlciIsIm9iamVjdCIsInN0cmluZyIsInN5bWJvbCIsImFueSIsImNyZWF0ZUFueVR5cGVDaGVja2VyIiwiYXJyYXlPZiIsImNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlciIsImVsZW1lbnQiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJlbGVtZW50VHlwZSIsImNyZWF0ZUVsZW1lbnRUeXBlVHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsIm5vZGUiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsIm9uZU9mIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwib25lT2ZUeXBlIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsInNoYXBlIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImV4YWN0IiwiY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlciIsImlzIiwieSIsIlByb3BUeXBlRXJyb3IiLCJkYXRhIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwibWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQiLCJjaGVja1R5cGUiLCJpc1JlcXVpcmVkIiwicHJvcHMiLCJwcm9wTmFtZSIsInByb3BGdWxsTmFtZSIsInNlY3JldCIsImNhY2hlS2V5IiwiY2hhaW5lZENoZWNrVHlwZSIsImJpbmQiLCJleHBlY3RlZFR5cGUiLCJwcm9wVmFsdWUiLCJwcm9wVHlwZSIsImdldFByb3BUeXBlIiwicHJlY2lzZVR5cGUiLCJnZXRQcmVjaXNlVHlwZSIsInR5cGVDaGVja2VyIiwiQXJyYXkiLCJpc0FycmF5IiwiaXNWYWxpZEVsZW1lbnRUeXBlIiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJ2YWx1ZXNTdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwicmVwbGFjZXIiLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsImV4cGVjdGVkVHlwZXMiLCJjaGVja2VyUmVzdWx0IiwicHVzaCIsImV4cGVjdGVkVHlwZXNNZXNzYWdlIiwiaXNOb2RlIiwiaW52YWxpZFZhbGlkYXRvckVycm9yIiwic2hhcGVUeXBlcyIsImFsbEtleXMiLCJzdGVwIiwiZW50cmllcyIsIm5leHQiLCJkb25lIiwiZW50cnkiLCJpc1N5bWJvbCIsIlJlZ0V4cCIsIkRhdGUiLCJjb25zdHJ1Y3RvciIsIlByb3BUeXBlcyIsImlzRWxlbWVudCIsIkZ1bmN0aW9uIiwiaGFzU3ltYm9sIiwiZm9yIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUkVBQ1RfU1RSSUNUX01PREVfVFlQRSIsIlJFQUNUX1BST0ZJTEVSX1RZUEUiLCJSRUFDVF9QUk9WSURFUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfQVNZTkNfTU9ERV9UWVBFIiwiUkVBQ1RfQ09OQ1VSUkVOVF9NT0RFX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX0JMT0NLX1RZUEUiLCJSRUFDVF9GVU5EQU1FTlRBTF9UWVBFIiwiUkVBQ1RfUkVTUE9OREVSX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiJCR0eXBlb2YiLCJ0eXBlT2YiLCIkJHR5cGVvZlR5cGUiLCJBc3luY01vZGUiLCJDb25jdXJyZW50TW9kZSIsIkNvbnRleHRDb25zdW1lciIsIkNvbnRleHRQcm92aWRlciIsIkVsZW1lbnQiLCJGb3J3YXJkUmVmIiwiRnJhZ21lbnQiLCJMYXp5IiwiTWVtbyIsIlBvcnRhbCIsIlByb2ZpbGVyIiwiU3RyaWN0TW9kZSIsIlN1c3BlbnNlIiwiaGFzV2FybmVkQWJvdXREZXByZWNhdGVkSXNBc3luY01vZGUiLCJpc0FzeW5jTW9kZSIsImlzQ29uY3VycmVudE1vZGUiLCJpc0NvbnRleHRDb25zdW1lciIsImlzQ29udGV4dFByb3ZpZGVyIiwiaXNGb3J3YXJkUmVmIiwiaXNGcmFnbWVudCIsImlzTGF6eSIsImlzTWVtbyIsImlzUG9ydGFsIiwiaXNQcm9maWxlciIsImlzU3RyaWN0TW9kZSIsImlzU3VzcGVuc2UiLCJzaGFsbG93RXF1YWxBcnJheXMiLCJzaGFsbG93RXF1YWxPYmplY3RzIiwib2JqQSIsIm9iakIiLCJhS2V5cyIsImJLZXlzIiwibGVuIiwiYXJyQSIsImFyckIiLCJfX3Jlc3QiLCJlIiwidCIsInAiLCJpbmRleE9mIiwiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsImRlZmluZVByb3BlcnR5IiwidXNlTWVkaWFRdWVyeV8xIiwiTWVkaWFRdWVyeSIsIl9hIiwiY2hpbGRyZW4iLCJkZXZpY2UiLCJvbkNoYW5nZSIsInNldHRpbmdzIiwiZGVmYXVsdCIsInJlYWN0XzEiLCJDb250ZXh0IiwiY3JlYXRlQ29udGV4dCIsInRvUXVlcnkiLCJ1c2VNZWRpYVF1ZXJ5IiwiQ29tcG9uZW50XzEiLCJ0b1F1ZXJ5XzEiLCJDb250ZXh0XzEiLCJfX2Fzc2lnbiIsImFwcGx5IiwicHJvcF90eXBlc18xIiwic3RyaW5nT3JOdW1iZXIiLCJ0eXBlcyIsImFsbCIsImdyaWQiLCJhdXJhbCIsImJyYWlsbGUiLCJoYW5kaGVsZCIsInByaW50IiwicHJvamVjdGlvbiIsInNjcmVlbiIsInR0eSIsInR2IiwiZW1ib3NzZWQiLCJtYXRjaGVycyIsIm9yaWVudGF0aW9uIiwic2NhbiIsImFzcGVjdFJhdGlvIiwiZGV2aWNlQXNwZWN0UmF0aW8iLCJoZWlnaHQiLCJkZXZpY2VIZWlnaHQiLCJ3aWR0aCIsImRldmljZVdpZHRoIiwiY29sb3IiLCJjb2xvckluZGV4IiwibW9ub2Nocm9tZSIsImZlYXR1cmVNYXRjaGVycyIsImZlYXR1cmVzIiwibWluQXNwZWN0UmF0aW8iLCJtYXhBc3BlY3RSYXRpbyIsIm1pbkRldmljZUFzcGVjdFJhdGlvIiwibWF4RGV2aWNlQXNwZWN0UmF0aW8iLCJtaW5IZWlnaHQiLCJtYXhIZWlnaHQiLCJtaW5EZXZpY2VIZWlnaHQiLCJtYXhEZXZpY2VIZWlnaHQiLCJtaW5XaWR0aCIsIm1heFdpZHRoIiwibWluRGV2aWNlV2lkdGgiLCJtYXhEZXZpY2VXaWR0aCIsIm1pbkNvbG9yIiwibWF4Q29sb3IiLCJtaW5Db2xvckluZGV4IiwibWF4Q29sb3JJbmRleCIsIm1pbk1vbm9jaHJvbWUiLCJtYXhNb25vY2hyb21lIiwibWluUmVzb2x1dGlvbiIsIm1heFJlc29sdXRpb24iLCJoeXBoZW5hdGVfc3R5bGVfbmFtZV8xIiwibWVkaWFRdWVyeV8xIiwibmVnYXRlIiwiY29uZCIsImNvbmNhdCIsImtleVZhbCIsImsiLCJ2IiwicmVhbEtleSIsImNvbmRzIiwib2JqIiwicnVsZXMiLCJtYXRjaG1lZGlhcXVlcnlfMSIsInNoYWxsb3dfZXF1YWxfMSIsIm1ha2VRdWVyeSIsImh5cGhlbmF0ZUtleXMiLCJyZWR1Y2UiLCJyZXN1bHQiLCJ1c2VJc1VwZGF0ZSIsInJlZiIsInVzZVJlZiIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJ1c2VEZXZpY2UiLCJkZXZpY2VGcm9tUHJvcHMiLCJkZXZpY2VGcm9tQ29udGV4dCIsInVzZUNvbnRleHQiLCJnZXREZXZpY2UiLCJ1c2VTdGF0ZSIsInNldERldmljZSIsIm5ld0RldmljZSIsInVzZVF1ZXJ5IiwiZ2V0UXVlcnkiLCJzZXRRdWVyeSIsIm5ld1F1ZXJ5IiwidXNlTWF0Y2hNZWRpYSIsImdldE1hdGNoTWVkaWEiLCJtcSIsInNldE1xIiwiaXNVcGRhdGUiLCJuZXdNcV8xIiwidXNlTWF0Y2hlcyIsInNldE1hdGNoZXMiLCJ1cGRhdGVNYXRjaGVzIiwiZXYiLCJkZXZpY2VTZXR0aW5ncyIsIl9fd2VicGFja19tb2R1bGVfY2FjaGVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwiZGVmaW5pdGlvbiIsIm8iLCJlbnVtZXJhYmxlIiwiZ2V0IiwicHJvcCIsInRvU3RyaW5nVGFnIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-responsive/dist/react-responsive.js\n");

/***/ })

};
;